/*
 * Copyright 2019-2021 The Polypheny Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * This file incorporates code covered by the following terms:
 *
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to you under the Apache License, Version 2.0
 * (the "License"); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


options {
  STATIC = false;
  LOOKAHEAD = 2;
  CHOICE_AMBIGUITY_CHECK = 2;
  OTHER_AMBIGUITY_CHECK = 1;
  FORCE_LA_CHECK = false;
  DEBUG_PARSER = false;
  DEBUG_LOOKAHEAD = false;
  DEBUG_TOKEN_MANAGER = false;
  ERROR_REPORTING = true;
  UNICODE_INPUT = true;
  IGNORE_CASE = true;
  BUILD_PARSER = true;
  BUILD_TOKEN_MANAGER = true;
  SANITY_CHECK = true;
  COMMON_TOKEN_ACTION = false;
  JDK_VERSION = "1.17";
  TOKEN_MANAGER_USES_PARSER = true;
}


PARSER_BEGIN(SqlParserImpl)

package org.polypheny.db.languages.sql.parser.impl;

import org.polypheny.db.schema.ColumnStrategy;
import org.polypheny.db.sql.language.SqlAlter;
import org.polypheny.db.sql.language.SqlBasicCall;
import org.polypheny.db.sql.language.SqlBinaryOperator;
import org.polypheny.db.sql.language.SqlCall;
import org.polypheny.db.sql.language.SqlCharStringLiteral;
import org.polypheny.db.sql.language.SqlCollation;
import org.polypheny.db.sql.language.SqlCreate;
import org.polypheny.db.sql.language.SqlDataTypeSpec;
import org.polypheny.db.sql.language.SqlDelete;
import org.polypheny.db.sql.language.SqlDescribeNamespace;
import org.polypheny.db.sql.language.SqlDescribeTable;
import org.polypheny.db.sql.language.SqlDrop;
import org.polypheny.db.sql.language.SqlDynamicParam;
import org.polypheny.db.sql.language.SqlExplain;
import org.polypheny.db.sql.language.SqlIdentifier;
import org.polypheny.db.sql.language.SqlInsert;
import org.polypheny.db.sql.language.SqlInsertKeyword;
import org.polypheny.db.sql.language.SqlIntervalQualifier;
import org.polypheny.db.sql.language.SqlJdbcDataTypeName;
import org.polypheny.db.sql.language.SqlJdbcFunctionCall;
import org.polypheny.db.sql.language.SqlJoin;
import org.polypheny.db.sql.language.SqlLiteral;
import org.polypheny.db.sql.language.SqlMatchRecognize;
import org.polypheny.db.sql.language.SqlMerge;
import org.polypheny.db.sql.language.SqlNode;
import org.polypheny.db.sql.language.SqlNodeList;
import org.polypheny.db.sql.language.SqlNumericLiteral;
import org.polypheny.db.sql.language.SqlOperator;
import org.polypheny.db.sql.language.SqlOrderBy;
import org.polypheny.db.sql.language.SqlPostfixOperator;
import org.polypheny.db.sql.language.SqlPrefixOperator;
import org.polypheny.db.sql.language.SqlSampleSpec;
import org.polypheny.db.sql.language.SqlSelect;
import org.polypheny.db.sql.language.SqlSelectKeyword;
import org.polypheny.db.sql.language.SqlSetOption;
import org.polypheny.db.sql.language.SqlUnnestOperator;
import org.polypheny.db.sql.language.SqlUpdate;
import org.polypheny.db.sql.language.SqlUtil;
import org.polypheny.db.sql.language.SqlWindow;
import org.polypheny.db.sql.language.SqlWith;
import org.polypheny.db.sql.language.SqlWithItem;
import org.polypheny.db.sql.language.ddl.SqlAlterAdaptersAdd;
import org.polypheny.db.sql.language.ddl.SqlAlterAdaptersDrop;
import org.polypheny.db.sql.language.ddl.SqlAlterConfig;
import org.polypheny.db.sql.language.ddl.SqlAlterInterfacesAdd;
import org.polypheny.db.sql.language.ddl.SqlAlterInterfacesDrop;
import org.polypheny.db.sql.language.ddl.SqlAlterMaterializedView;
import org.polypheny.db.sql.language.ddl.SqlAlterNamespace;
import org.polypheny.db.sql.language.ddl.SqlAlterTable;
import org.polypheny.db.sql.language.ddl.SqlAlterView;
import org.polypheny.db.sql.language.ddl.SqlDdlNodes;
import org.polypheny.db.sql.language.ddl.SqlTruncate;
import org.polypheny.db.sql.language.ddl.altermaterializedview.SqlAlterMaterializedViewAddIndex;
import org.polypheny.db.sql.language.ddl.altermaterializedview.SqlAlterMaterializedViewDropIndex;
import org.polypheny.db.sql.language.ddl.altermaterializedview.SqlAlterMaterializedViewFreshnessManual;
import org.polypheny.db.sql.language.ddl.altermaterializedview.SqlAlterMaterializedViewRename;
import org.polypheny.db.sql.language.ddl.altermaterializedview.SqlAlterMaterializedViewRenameColumn;
import org.polypheny.db.sql.language.ddl.alternamespace.SqlAlterNamespaceOwner;
import org.polypheny.db.sql.language.ddl.alternamespace.SqlAlterNamespaceRename;
import org.polypheny.db.sql.language.ddl.altertable.SqlAlterSourceTableAddColumn;
import org.polypheny.db.sql.language.ddl.altertable.SqlAlterTableAddColumn;
import org.polypheny.db.sql.language.ddl.altertable.SqlAlterTableAddForeignKey;
import org.polypheny.db.sql.language.ddl.altertable.SqlAlterTableAddIndex;
import org.polypheny.db.sql.language.ddl.altertable.SqlAlterTableAddPartitions;
import org.polypheny.db.sql.language.ddl.altertable.SqlAlterTableAddPlacement;
import org.polypheny.db.sql.language.ddl.altertable.SqlAlterTableAddPrimaryKey;
import org.polypheny.db.sql.language.ddl.altertable.SqlAlterTableAddUniqueConstraint;
import org.polypheny.db.sql.language.ddl.altertable.SqlAlterTableDropColumn;
import org.polypheny.db.sql.language.ddl.altertable.SqlAlterTableDropConstraint;
import org.polypheny.db.sql.language.ddl.altertable.SqlAlterTableDropForeignKey;
import org.polypheny.db.sql.language.ddl.altertable.SqlAlterTableDropIndex;
import org.polypheny.db.sql.language.ddl.altertable.SqlAlterTableDropPlacement;
import org.polypheny.db.sql.language.ddl.altertable.SqlAlterTableDropPrimaryKey;
import org.polypheny.db.sql.language.ddl.altertable.SqlAlterTableMergePartitions;
import org.polypheny.db.sql.language.ddl.altertable.SqlAlterTableModifyColumn;
import org.polypheny.db.sql.language.ddl.altertable.SqlAlterTableModifyPartitions;
import org.polypheny.db.sql.language.ddl.altertable.SqlAlterTableModifyPlacement;
import org.polypheny.db.sql.language.ddl.altertable.SqlAlterTableModifyPlacementAddColumn;
import org.polypheny.db.sql.language.ddl.altertable.SqlAlterTableModifyPlacementDropColumn;
import org.polypheny.db.sql.language.ddl.altertable.SqlAlterTableOwner;
import org.polypheny.db.sql.language.ddl.altertable.SqlAlterTableRename;
import org.polypheny.db.sql.language.ddl.altertable.SqlAlterTableRenameColumn;
import org.polypheny.db.sql.language.ddl.alterview.SqlAlterViewRename;
import org.polypheny.db.sql.language.ddl.alterview.SqlAlterViewRenameColumn;
import org.polypheny.db.sql.language.fun.OracleSqlOperatorTable;
import org.polypheny.db.sql.language.fun.SqlArrayValueConstructor;
import org.polypheny.db.sql.language.fun.SqlCase;
import org.polypheny.db.sql.language.fun.SqlJsonArrayAggAggFunction;
import org.polypheny.db.sql.language.fun.SqlJsonObjectAggAggFunction;
import org.polypheny.db.sql.language.fun.SqlStdOperatorTable;
import org.polypheny.db.sql.language.fun.SqlTrimFunction;
import org.polypheny.db.sql.language.parser.Span;
import org.polypheny.db.sql.language.parser.SqlAbstractParserImpl;
import org.polypheny.db.sql.language.parser.SqlAbstractParserImpl.ExprContext;
import org.polypheny.db.sql.language.parser.SqlAbstractParserImpl.MetadataImpl;
import org.polypheny.db.sql.language.parser.SqlParser;
import org.polypheny.db.sql.language.parser.SqlParserUtil;
import java.util.Map;
import java.util.HashMap;
import org.polypheny.db.util.CoreUtil;


import org.polypheny.db.catalog.logistic.DataModel;
import org.polypheny.db.languages.ParserFactory;
import org.polypheny.db.util.Conformance;
import org.polypheny.db.languages.NodeParseException;
import org.polypheny.db.languages.ParserPos;
import org.polypheny.db.languages.OperatorRegistry;
import org.polypheny.db.algebra.constant.ExplainFormat;
import org.polypheny.db.algebra.constant.JoinConditionType;
import org.polypheny.db.algebra.constant.JoinType;
import org.polypheny.db.algebra.constant.ExplainLevel;
import org.polypheny.db.algebra.constant.FunctionCategory;
import org.polypheny.db.algebra.constant.Kind;
import org.polypheny.db.nodes.Explain;
import org.polypheny.db.nodes.Identifier;
import org.polypheny.db.util.CoreUtil;
import org.polypheny.db.algebra.operators.OperatorName;
import org.apache.calcite.avatica.util.Casing;
import org.polypheny.db.util.temporal.DateTimeUtils;
import org.polypheny.db.util.temporal.TimeUnit;
import org.polypheny.db.algebra.type.AlgDataType;
import org.polypheny.db.runtime.PolyphenyDbContextException;
import org.polypheny.db.algebra.json.JsonConstructorNullClause;
import org.polypheny.db.algebra.json.JsonEncoding;
import org.polypheny.db.algebra.json.JsonExistsErrorBehavior;
import org.polypheny.db.algebra.json.JsonEmptyOrError;
import org.polypheny.db.algebra.json.JsonQueryEmptyOrErrorBehavior;
import org.polypheny.db.algebra.json.JsonQueryWrapperBehavior;
import org.polypheny.db.algebra.json.JsonValueEmptyOrErrorBehavior;
import org.polypheny.db.algebra.metadata.Metadata;
import org.polypheny.db.type.PolyType;
import org.polypheny.db.util.Glossary;
import org.polypheny.db.util.NlsString;
import org.polypheny.db.util.Pair;
import org.polypheny.db.util.SourceStringReader;
import org.polypheny.db.util.Util;
import org.polypheny.db.util.trace.PolyphenyDbTrace;
import org.polypheny.db.catalog.Catalog;
import org.polypheny.db.partition.raw.*;

import org.slf4j.Logger;

import java.io.Reader;
import java.lang.Math;
import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Calendar;
import java.util.Collections;
import java.util.List;
import java.util.Locale;

import static org.polypheny.db.util.Static.RESOURCE;

/**
 * SQL parser, generated from Parser.jj by JavaCC.
 *
 * The public wrapper for this parser is {@link SqlParser}.
 */
public class SqlParserImpl extends SqlAbstractParserImpl
{
    private static final Logger LOGGER = PolyphenyDbTrace.getParserTracer();

    // Can't use quoted literal because of a bug in how JavaCC translates backslash-backslash.
    private static final char BACKSLASH = 0x5c;
    private static final char DOUBLE_QUOTE = 0x22;
    private static final String DQ = DOUBLE_QUOTE + "";
    private static final String DQDQ = DQ + DQ;

    private static Metadata metadata;

    private Casing unquotedCasing;
    private Casing quotedCasing;
    private int identifierMaxLength;
    private Conformance conformance;

    /**
     * {@link ParserFactory} implementation for creating parser.
     */
    public static final ParserFactory FACTORY = new ParserFactory() {
        public SqlAbstractParserImpl getParser(Reader reader) {
            final SqlParserImpl parser = new SqlParserImpl(reader);
            if (reader instanceof SourceStringReader) {
                final String sql = ((SourceStringReader) reader).getSourceString();
                parser.setOriginalSql(sql);
            }
          return parser;
        }
    };

    public NodeParseException normalizeException(Throwable ex)
    {
        try {
            if (ex instanceof ParseException) {
                ex = cleanupParseException((ParseException) ex);
            }
            return convertException(ex);
        } catch (ParseException e) {
            throw new AssertionError(e);
        }
    }

    public Metadata getMetadata()
    {
        synchronized (SqlParserImpl.class) {
            if (metadata == null) {
                metadata = new MetadataImpl(new SqlParserImpl(new java.io.StringReader("")));
            }
            return metadata;
        }
    }

    public void setTabSize(int tabSize)
    {
        jj_input_stream.setTabSize(tabSize);
    }

    public void switchTo(String stateName)
    {
        int state = Arrays.asList(SqlParserImplTokenManager.lexStateNames).indexOf(stateName);
        token_source.SwitchTo(state);
    }

    public void setQuotedCasing(Casing quotedCasing)
    {
        this.quotedCasing = quotedCasing;
    }

    public void setUnquotedCasing(Casing unquotedCasing)
    {
        this.unquotedCasing = unquotedCasing;
    }

    public void setIdentifierMaxLength(int identifierMaxLength)
    {
        this.identifierMaxLength = identifierMaxLength;
    }

    public void setConformance(Conformance conformance)
    {
        this.conformance = conformance;
    }

    public SqlNode parseSqlExpressionEof() throws Exception
    {
        return SqlExpressionEof();
    }

    public SqlNode parseSqlStmtEof() throws Exception
    {
        return SqlStmtEof();
    }

    private SqlNode extend(SqlNode table, SqlNodeList extendList) {
        return (SqlNode) OperatorRegistry.get( OperatorName.EXTEND ).createCall(Span.of(table, extendList).pos(), table, extendList);
    }
}

PARSER_END(SqlParserImpl)


/***************************************
 * Utility Codes for Semantic Analysis *
 ***************************************/

/* For Debug */
JAVACODE
void debug_message1() {
    LOGGER.info("{} , {}", getToken(0).image, getToken(1).image);
}

JAVACODE String unquotedIdentifier() {
    return CoreUtil.strip(getToken(0).image, null, null, null, unquotedCasing);
}

/**
 * Allows parser to be extended with new types of table references.  The
 * default implementation of this production is empty.
 */
SqlNode ExtendedTableRef() :
{
}
{
    UnusedExtension()
    {
        return null;
    }
}

/**
 * Allows an OVER clause following a table expression as an extension to
 * standard SQL syntax. The default implementation of this production is empty.
 */
SqlNode TableOverOpt() :
{
}
{
    {
        return null;
    }
}

/*
 * Parses dialect-specific keywords immediately following the SELECT keyword.
 */
void SqlSelectKeywords(List<SqlLiteral> keywords) :
{}
{
    E()
}

/*
 * Parses dialect-specific keywords immediately following the INSERT keyword.
 */
void SqlInsertKeywords(List<SqlLiteral> keywords) :
{}
{
    E()
}

SqlNode ExtendedBuiltinFunctionCall() :
{
}
{
    UnusedExtension()
    {
        return null;
    }
}

/*
* Parse Floor/Ceil function parameters
*/
SqlNode FloorCeilOptions(Span s, boolean floorFlag) :
{
    SqlNode node;
}
{
    node = StandardFloorCeilOptions(s, floorFlag) {
        return node;
    }
}

/*
// This file contains the heart of a parser for SQL SELECT statements.
// code can be shared between various parsers (for example, a DDL parser and a
// DML parser) but is not a standalone JavaCC file. You need to prepend a
// parser declaration (such as that in Parser.jj).
*/

/* Epsilon */
JAVACODE
void E() {}

JAVACODE List startList(Object o)
{
    List list = new ArrayList();
    list.add(o);
    return list;
}

/*
 * NOTE jvs 6-Feb-2004: The straightforward way to implement the SQL grammar is
 * to keep query expressions (SELECT, UNION, etc) separate from row expressions
 * (+, LIKE, etc).  However, this is not possible with an LL(k) parser, because
 * both kinds of expressions allow parenthesization, so no fixed amount of left
 * context is ever good enough.  A sub-query can be a leaf in a row expression,
 * and can include operators like UNION, so it's not even possible to use a
 * syntactic lookahead rule like "look past an indefinite number of parentheses
 * until you see SELECT, VALUES, or TABLE" (since at that point we still
 * don't know whether we're parsing a sub-query like ((select ...) + x)
 * vs. (select ... union select ...).
 *
 * The somewhat messy solution is to unify the two kinds of expression,
 * and to enforce syntax rules using parameterized context.  This
 * is the purpose of the ExprContext parameter.  It is passed to
 * most expression productions, which check the expressions encountered
 * against the context for correctness.  When a query
 * element like SELECT is encountered, the production calls
 * checkQueryExpression, which will throw an exception if
 * a row expression was expected instead.  When a row expression like
 * IN is encountered, the production calls checkNonQueryExpression
 * instead.  It is very important to understand how this works
 * when modifying the grammar.
 *
 * The commingling of expressions results in some bogus ambiguities which are
 * resolved with LOOKAHEAD hints.  The worst example is comma.  SQL allows both
 * (WHERE x IN (1,2)) and (WHERE x IN (select ...)).  This means when we parse
 * the right-hand-side of an IN, we have to allow any kind of expression inside
 * the parentheses.  Now consider the expression "WHERE x IN(SELECT a FROM b
 * GROUP BY c,d)".  When the parser gets to "c,d" it doesn't know whether the
 * comma indicates the end of the GROUP BY or the end of one item in an IN
 * list.  Luckily, we know that select and comma-list are mutually exclusive
 * within IN, so we use maximal munch for the GROUP BY comma.  However, this
 * usage of hints could easily mask unintended ambiguities resulting from
 * future changes to the grammar, making it very brittle.
 */

JAVACODE protected ParserPos getPos()
{
    return new ParserPos(
        token.beginLine,
        token.beginColumn,
        token.endLine,
        token.endColumn);
}

/** Starts a span at the current position. */
JAVACODE Span span()
{
    return Span.of(getPos());
}

JAVACODE void checkQueryExpression(ExprContext exprContext)
{
    switch (exprContext) {
    case ACCEPT_NON_QUERY:
    case ACCEPT_SUB_QUERY:
    case ACCEPT_CURSOR:
        throw CoreUtil.newContextException(getPos(), RESOURCE.illegalQueryExpression());
    }
}

JAVACODE void checkNonQueryExpression(ExprContext exprContext)
{
    switch (exprContext) {
    case ACCEPT_QUERY:
        throw CoreUtil.newContextException(getPos(), RESOURCE.illegalNonQueryExpression());
    }
}

/**
 * Converts a ParseException (local to this particular instantiation
 * of the parser) into a SqlParseException (common to all parsers).
 */
JAVACODE NodeParseException convertException(Throwable ex)
{
    if (ex instanceof NodeParseException) {
        return (NodeParseException) ex;
    }
    ParserPos pos = null;
    int[][] expectedTokenSequences = null;
    String[] tokenImage = null;
    if (ex instanceof ParseException) {
        ParseException pex = (ParseException) ex;
        expectedTokenSequences = pex.expectedTokenSequences;
        tokenImage = pex.tokenImage;
        if (pex.currentToken != null) {
            final Token token = pex.currentToken.next;
            pos = new ParserPos(
                token.beginLine,
                token.beginColumn,
                token.endLine,
                token.endColumn);
        }
    } else if (ex instanceof TokenMgrError) {
        TokenMgrError tme = (TokenMgrError) ex;
        expectedTokenSequences = null;
        tokenImage = null;
        // Example:
        //    Lexical error at line 3, column 24.  Encountered "#" after "a".
        final java.util.regex.Pattern pattern = java.util.regex.Pattern.compile(
            "(?s)Lexical error at line ([0-9]+), column ([0-9]+).*");
        java.util.regex.Matcher matcher = pattern.matcher(ex.getMessage());
        if (matcher.matches()) {
            int line = Integer.parseInt(matcher.group(1));
            int column = Integer.parseInt(matcher.group(2));
            pos = new ParserPos(line, column, line, column);
        }
    } else if (ex instanceof PolyphenyDbContextException) {
        // PolyphenyDbContextException is the standard wrapper for exceptions
        // produced by the validator, but in the parser, the standard is
        // SqlParseException; so, strip it away. In case you were wondering,
        // the PolyphenyDbContextException appears because the parser
        // occasionally calls into validator-style code such as
        // SqlSpecialOperator.reduceExpr.
        PolyphenyDbContextException ece =
            (PolyphenyDbContextException) ex;
        pos = new ParserPos(
            ece.getPosLine(),
            ece.getPosColumn(),
            ece.getEndPosLine(),
            ece.getEndPosColumn());
        ex = ece.getCause();
    }

    return new NodeParseException(
        ex.getMessage(), pos, expectedTokenSequences, tokenImage, ex);
}

/**
 * Removes or transforms misleading information from a parse exception.
 *
 * @param e dirty excn
 *
 * @return clean excn
 */
JAVACODE ParseException cleanupParseException(ParseException ex)
{
    if (ex.expectedTokenSequences == null) {
        return ex;
    }
    int iIdentifier = Arrays.asList(ex.tokenImage).indexOf("<IDENTIFIER>");

    // Find all sequences in the error which contain identifier. For
    // example,
    //       {<IDENTIFIER>}
    //       {A}
    //       {B, C}
    //       {D, <IDENTIFIER>}
    //       {D, A}
    //       {D, B}
    //
    // would yield
    //       {}
    //       {D}
    boolean id = false;
    final List<int[]> prefixList = new ArrayList<int[]>();
    for (int i = 0; i < ex.expectedTokenSequences.length; ++i) {
        int[] seq = ex.expectedTokenSequences[i];
        int j = seq.length - 1;
        int i1 = seq[j];
        if (i1 == iIdentifier) {
            int[] prefix = new int[j];
            System.arraycopy(seq, 0, prefix, 0, j);
            prefixList.add(prefix);
        }
    }

    if (prefixList.isEmpty()) {
        return ex;
    }

    int[][] prefixes = (int[][])
        prefixList.toArray(new int[prefixList.size()][]);

    // Since <IDENTIFIER> was one of the possible productions,
    // we know that the parser will also have included all
    // of the non-reserved keywords (which are treated as
    // identifiers in non-keyword contexts).  So, now we need
    // to clean those out, since they're totally irrelevant.

    final List<int[]> list = new ArrayList<int[]>();
    Metadata metadata = getMetadata();
    for (int i = 0; i < ex.expectedTokenSequences.length; ++i) {
        int [] seq = ex.expectedTokenSequences[i];
        String tokenImage = ex.tokenImage[seq[seq.length - 1]];
        String token = SqlParserUtil.getTokenVal(tokenImage);
        if (token == null  || !metadata.isNonReservedKeyword(token)) {
            list.add(seq);
            continue;
        }
        boolean match = matchesPrefix(seq, prefixes);
        if (!match) {
            list.add(seq);
        }
    }

    ex.expectedTokenSequences =
        (int [][]) list.toArray(new int [list.size()][]);
    return ex;
}

JAVACODE boolean matchesPrefix(int[] seq, int[][] prefixes)
{
    nextPrefix:
    for (int[] prefix : prefixes) {
        if (seq.length == prefix.length + 1) {
            for (int k = 0; k < prefix.length; k++) {
                if (prefix[k] != seq[k]) {
                    continue nextPrefix;
                }
            }
            return true;
        }
    }
    return false;
}

/*****************************************
 * Syntactical Descriptions              *
 *****************************************/

/**
 * Parses either a row expression or a query expression with an optional
 * ORDER BY.
 *
 * <p>Postgres syntax for limit:
 *
 * <blockquote><pre>
 *    [ LIMIT { count | ALL } ]
 *    [ OFFSET start ]</pre>
 * </blockquote>
 *
 * <p>MySQL syntax for limit:
 *
 * <blockquote><pre>
 *    [ LIMIT { count | start, count } ]</pre>
 * </blockquote>
 *
 * <p>SQL:2008 syntax for limit:
 *
 * <blockquote><pre>
 *    [ OFFSET start { ROW | ROWS } ]
 *    [ FETCH { FIRST | NEXT } [ count ] { ROW | ROWS } ONLY ]</pre>
 * </blockquote>
 */
SqlNode OrderedQueryOrExpr(ExprContext exprContext) :
{
    SqlNode e;
    SqlNodeList orderBy = null;
    SqlNode start = null;
    SqlNode count = null;
}
{
    (
        e = QueryOrExpr(exprContext)
    )
    [
        // use the syntactic type of the expression we just parsed
        // to decide whether ORDER BY makes sense
        orderBy = OrderBy(e.isA(Kind.QUERY))
    ]
    [
        // Postgres-style syntax. "LIMIT ... OFFSET ..."
        <LIMIT>
        (
            // MySQL-style syntax. "LIMIT start, count"
            start = UnsignedNumericLiteralOrParam()
            <COMMA> count = UnsignedNumericLiteralOrParam() {
                if (!this.conformance.isLimitStartCountAllowed()) {
                    throw new ParseException(RESOURCE.limitStartCountNotAllowed().str());
                }
            }
        |
            count = UnsignedNumericLiteralOrParam()
        |
            <ALL>
        )
    ]
    [
        // ROW or ROWS is required in SQL:2008 but we make it optional
        // because it is not present in Postgres-style syntax.
        // If you specify both LIMIT start and OFFSET, OFFSET wins.
        <OFFSET> start = UnsignedNumericLiteralOrParam() [ <ROW> | <ROWS> ]
    ]
    [
        // SQL:2008-style syntax. "OFFSET ... FETCH ...".
        // If you specify both LIMIT and FETCH, FETCH wins.
        <FETCH> ( <FIRST> | <NEXT> ) count = UnsignedNumericLiteralOrParam()
        ( <ROW> | <ROWS> ) <ONLY>
    ]
    {
        if (orderBy != null || start != null || count != null) {
            if (orderBy == null) {
                orderBy = SqlNodeList.EMPTY;
            }
            e = new SqlOrderBy(getPos(), e, orderBy, start, count);

        }
        return e;
    }
}

/**
 * Parses a leaf in a query expression (SELECT, VALUES or TABLE).
 */
SqlNode LeafQuery(ExprContext exprContext) :
{
    SqlNode e;
}
{
    {
        // ensure a query is legal in this context
        checkQueryExpression(exprContext);
    }
    e = SqlSelect() { return e; }
|
    e = TableConstructor() { return e; }
|
    e = ExplicitTable(getPos()) { return e; }
}

/**
 * Parses a parenthesized query or single row expression.
 */
SqlNode ParenthesizedExpression(ExprContext exprContext) :
{
    SqlNode e;
}
{
    <LPAREN>
    {
        // we've now seen left paren, so queries inside should
        // be allowed as sub-queries
        switch (exprContext) {
        case ACCEPT_SUB_QUERY:
            exprContext = ExprContext.ACCEPT_NONCURSOR;
            break;
        case ACCEPT_CURSOR:
            exprContext = ExprContext.ACCEPT_ALL;
            break;
        }
    }
    e = OrderedQueryOrExpr(exprContext)
    <RPAREN>
    {
        return e;
    }
}

/**
 * Parses a parenthesized query or comma-list of row expressions.
 *
 * <p>REVIEW jvs: There's a small hole in this production.  It can be
 * used to construct something like
 *
 * <blockquote><pre>
 * WHERE x IN (select count(*) from t where c=d,5)</pre>
 * </blockquote>
 *
 * <p>which should be illegal.  The above is interpreted as equivalent to
 *
 * <blockquote><pre>
 * WHERE x IN ((select count(*) from t where c=d),5)</pre>
 * </blockquote>
 *
 * <p>which is a legal use of a sub-query.  The only way to fix the hole is to
 * be able to remember whether a subexpression was parenthesized or not, which
 * means preserving parentheses in the SqlNode tree.  This is probably
 * desirable anyway for use in purely syntactic parsing applications (e.g. SQL
 * pretty-printer).  However, if this is done, it's important to also make
 * isA() on the paren node call down to its operand so that we can
 * always correctly discriminate a query from a row expression.
 */
SqlNodeList ParenthesizedQueryOrCommaList(
    ExprContext exprContext) :
{
    SqlNode e;
    List<SqlNode> list;
    ExprContext firstExprContext = exprContext;
    final Span s;
}
{
    <LPAREN>
    {
        // we've now seen left paren, so a query by itself should
        // be interpreted as a sub-query
        s = span();
        switch (exprContext) {
        case ACCEPT_SUB_QUERY:
            firstExprContext = ExprContext.ACCEPT_NONCURSOR;
            break;
        case ACCEPT_CURSOR:
            firstExprContext = ExprContext.ACCEPT_ALL;
            break;
        }
    }
    e = OrderedQueryOrExpr(firstExprContext)
    {
        list = startList(e);
    }
    (
        <COMMA>
        {
            // a comma-list can't appear where only a query is expected
            checkNonQueryExpression(exprContext);
        }
        e = Expression(exprContext)
        {
            list.add(e);
        }
    )*
    <RPAREN>
    {
        return new SqlNodeList(list, s.end(this));
    }
}

/** As ParenthesizedQueryOrCommaList, but allows DEFAULT
 * in place of any of the expressions. For example,
 * {@code (x, DEFAULT, null, DEFAULT)}. */
SqlNodeList ParenthesizedQueryOrCommaListWithDefault(
    ExprContext exprContext) :
{
    SqlNode e;
    List<SqlNode> list;
    ExprContext firstExprContext = exprContext;
    final Span s;
}
{
    <LPAREN>
    {
        // we've now seen left paren, so a query by itself should
        // be interpreted as a sub-query
        s = span();
        switch (exprContext) {
        case ACCEPT_SUB_QUERY:
            firstExprContext = ExprContext.ACCEPT_NONCURSOR;
            break;
        case ACCEPT_CURSOR:
            firstExprContext = ExprContext.ACCEPT_ALL;
            break;
        }
    }
    (
        e = OrderedQueryOrExpr(firstExprContext)
    |
        e = Default()
    )
    {
        list = startList(e);
    }
    (
        <COMMA>
        {
            // a comma-list can't appear where only a query is expected
            checkNonQueryExpression(exprContext);
        }
        (
            e = Expression(exprContext)
        |
            e = Default()
        )
        {
            list.add(e);
        }
    )*
    <RPAREN>
    {
        return new SqlNodeList(list, s.end(this));
    }
}

/**
 * Parses function parameter lists including DISTINCT keyword recognition,
 * DEFAULT, and named argument assignment.
 */
List FunctionParameterList(
    ExprContext exprContext) :
{
    SqlNode e = null;
    List list = new ArrayList();
}
{
    <LPAREN>
    [
        <DISTINCT> {
            e = SqlLiteral.createSymbol(SqlSelectKeyword.DISTINCT, getPos());
        }
    |
        <ALL> {
            e = SqlLiteral.createSymbol(SqlSelectKeyword.ALL, getPos());
        }
    ]
    {
        list.add(e);
    }
    Arg0(list, exprContext)
    (
        <COMMA> {
            // a comma-list can't appear where only a query is expected
            checkNonQueryExpression(exprContext);
        }
        Arg(list, exprContext)
    )*
    <RPAREN>
    {
        return list;
    }
}

void Arg0(List list, ExprContext exprContext) :
{
    SqlIdentifier name = null;
    SqlNode e = null;
    final ExprContext firstExprContext;
    {
        // we've now seen left paren, so queries inside should
        // be allowed as sub-queries
        switch (exprContext) {
        case ACCEPT_SUB_QUERY:
            firstExprContext = ExprContext.ACCEPT_NONCURSOR;
            break;
        case ACCEPT_CURSOR:
            firstExprContext = ExprContext.ACCEPT_ALL;
            break;
        default:
            firstExprContext = exprContext;
            break;
        }
    }
}
{
    [
        name = SimpleIdentifier() <NAMED_ARGUMENT_ASSIGNMENT>
    ]
    (
        e = Default()
    |
        e = OrderedQueryOrExpr(firstExprContext)
    )
    {
        if (e != null) {
            if (name != null) {
                e = (SqlCall)OperatorRegistry.get( OperatorName.ARGUMENT_ASSIGNMENT ).createCall(
                    Span.of(name, e).pos(), e, name);
            }
            list.add(e);
        }
    }
}

void Arg(List list, ExprContext exprContext) :
{
    SqlIdentifier name = null;
    SqlNode e = null;
}
{
    [
        name = SimpleIdentifier() <NAMED_ARGUMENT_ASSIGNMENT>
    ]
    (
        e = Default()
    |
        e = Expression(exprContext)
    )
    {
        if (e != null) {
            if (name != null) {
                e = (SqlCall) OperatorRegistry.get( OperatorName.ARGUMENT_ASSIGNMENT ).createCall( Span.of(name, e).pos(), e, name );
            }
            list.add(e);
        }
    }
}

SqlNode Default() : {}
{
    <DEFAULT_> {
        return (SqlCall) OperatorRegistry.get( OperatorName.DEFAULT ).createCall(getPos());
    }
}

/**
 * Parses a query (SELECT, UNION, INTERSECT, EXCEPT, VALUES, TABLE) followed by
 * the end-of-file symbol.
 */
SqlNode SqlQueryEof() :
{
    SqlNode query;
}
{
    query = OrderedQueryOrExpr(ExprContext.ACCEPT_QUERY)
    <EOF>
    { return query; }
}

/**
 * Parses an SQL statement.
 */
SqlNode SqlStmt() :
{
    SqlNode stmt;
}
{
    (
        stmt = SqlTruncateTable()
    |

//        stmt = SqlSetOption(Span.of())
//    |
        stmt = SqlAlter()
    |
        stmt = SqlCreate()
    |
        stmt = SqlDrop()
    |
        stmt = OrderedQueryOrExpr(ExprContext.ACCEPT_QUERY)
    |
        stmt = Explain()
    |
        stmt = SqlDescribe()
    |
        stmt = SqlInsert()
    |
        stmt = SqlDelete()
    |
        stmt = SqlUpdate()
    |
        stmt = SqlMerge()
    |
        stmt = SqlProcedureCall()
    )
    {
        return stmt;
    }
}

/**
 * Parses an SQL statement followed by the end-of-file symbol.
 */
SqlNode SqlStmtEof() :
{
    SqlNode stmt;
}
{
    stmt = SqlStmt() <EOF>
    {
        return stmt;
    }
}

////////////////////////////////////
/////////////parserimpl start

/**
* Parses a TRUNCATE TABLE statement.
*/
SqlTruncate SqlTruncateTable() :
{
    final Span s;
    final SqlIdentifier entity;
}
{
    <TRUNCATE> { s = span(); }
    <TABLE> entity = CompoundIdentifier()
    {
        return new SqlTruncate(s.end(this), entity);
    }
}


/**
* Parses a ALTER NAMESPACE statement.
*/
SqlAlterNamespace SqlAlterNamespace(Span s) :
{
    final SqlIdentifier namespace;
    final SqlIdentifier name;
    final SqlIdentifier owner;
}
{
    (<NAMESPACE>|<SCHEMA>)
    namespace = CompoundIdentifier()
    (
        <RENAME> <TO>
        name = CompoundIdentifier()
        {
            return new SqlAlterNamespaceRename(s.end(this), namespace, name);
        }
    |
        <OWNER> <TO>
        owner = SimpleIdentifier()
        {
            return new SqlAlterNamespaceOwner(s.end(this), namespace, owner);
        }
    )
}

/**
* Parses a ALTER VIEW statement.
**/
SqlAlterView SqlAlterView(Span s) :
{
    final SqlIdentifier view;
    final SqlIdentifier name;
    final SqlIdentifier column;
}
{
    <VIEW>
    view = CompoundIdentifier()
    (
        <RENAME><TO>
        name = SimpleIdentifier()
        {
            return new SqlAlterViewRename(s.end(this), view, name);
        }
    |
        <RENAME> <COLUMN>
        column = SimpleIdentifier()
        <TO>
        name = SimpleIdentifier()
        {
            return new SqlAlterViewRenameColumn(s.end(this), view, column, name);
        }
    )
}

/**
* Parses a ALTER MATERIALIZED VIEW statement.
**/
SqlAlterMaterializedView SqlAlterMaterializedView(Span s) :
{
    final SqlIdentifier materializedview;
    final SqlIdentifier name;
    final SqlIdentifier column;
    final SqlIdentifier store;
    final SqlIdentifier indexName;
    final SqlNodeList columnList;
    final SqlIdentifier indexMethod;
    final boolean unique;
    final SqlIdentifier storeName;

}
{
    <MATERIALIZED><VIEW>
    materializedview = CompoundIdentifier()
    (
        <RENAME><TO>
            name = SimpleIdentifier()
            {
            return new SqlAlterMaterializedViewRename(s.end(this), materializedview, name);
            }
    |
        <RENAME> <COLUMN>
            column = SimpleIdentifier()
            <TO>
            name = SimpleIdentifier()
            {
                return new SqlAlterMaterializedViewRenameColumn(s.end(this), materializedview, column, name);
            }
    |
        <FRESHNESS><MANUAL>
            {
                return new SqlAlterMaterializedViewFreshnessManual(s.end(this), materializedview);
            }
    |
        <ADD>
            (
            <UNIQUE> { unique = true; }
            |
            { unique = false; }
            )
            <INDEX>
                indexName = SimpleIdentifier()
            <ON>
            (
            columnList = ParenthesizedSimpleIdentifierList()
            |
            column = SimpleIdentifier()
            {
                columnList = new SqlNodeList(Arrays.asList( new SqlNode[]{ column }), s.end(this));
            }
            )
            (
            <USING> indexMethod = SimpleIdentifier()
            |
            { indexMethod = null; }
            )
            (
            <ON> <STORE> storeName = SimpleIdentifier()
            |
            { storeName = null; }
            )
            {
            return new SqlAlterMaterializedViewAddIndex(s.end(this), materializedview, columnList, unique, indexMethod, indexName, storeName);
            }
    |
        <DROP> <INDEX>
            indexName = SimpleIdentifier()
            {
            return new SqlAlterMaterializedViewDropIndex(s.end(this), materializedview, indexName);
            }

    )
}

/**
* Parses a ALTER TABLE statement.
*/
SqlAlterTable SqlAlterTable(Span s) :
{
    final SqlIdentifier entity;
    final SqlIdentifier column;
    final SqlIdentifier name;
    final SqlIdentifier owner;
    final SqlDataTypeSpec type;
    final boolean nullable;
    final SqlNode defaultValue;
    final SqlIdentifier beforeColumn;
    final SqlIdentifier afterColumn;
    final SqlAlterTable statement;
    final SqlNodeList columnList;
    final SqlNodeList referencesList;
    final SqlIdentifier refColumn;
    final SqlIdentifier refTable;
    final SqlIdentifier constraintName;
    final SqlIdentifier store;
    final SqlIdentifier indexName;
    final SqlIdentifier indexMethod;
    final SqlIdentifier storeName;
    final String onUpdate;
    final String onDelete;
    final boolean unique;
    final SqlIdentifier physicalName;
    final SqlIdentifier partitionType;
    SqlIdentifier partitionColumn; // error in javacc
    List<Integer> partitionList = new ArrayList<Integer>();
    int partitionIndex = 0;
    int numPartitionGroups = 0;
    int numPartitions = 0;
    List<SqlIdentifier> partitionNamesList = new ArrayList<SqlIdentifier>();
    SqlIdentifier partitionName = null;
    List< List<SqlNode>> partitionQualifierList = new ArrayList<List<SqlNode>>();
    List<SqlNode> partitionQualifiers = new ArrayList<SqlNode>();
    SqlNode partitionValues = null;
    SqlIdentifier tmpIdent = null;
    int tmpInt = 0;
    RawPartitionInformation rawPartitionInfo;
}
{
    <TABLE>
    entity = CompoundIdentifier()
    (
        <RENAME> <TO>
        name = SimpleIdentifier()
        {
            return new SqlAlterTableRename(s.end(this), entity, name);
        }
    |
        <OWNER> <TO>
        owner = SimpleIdentifier()
        {
            return new SqlAlterTableOwner(s.end(this), entity, owner);
        }
    |
        <RENAME> <COLUMN>
        column = SimpleIdentifier()
        <TO>
        name = SimpleIdentifier()
        {
            return new SqlAlterTableRenameColumn(s.end(this), entity, column, name);
        }
    |
        <ADD> <COLUMN>
        name = SimpleIdentifier()
        (
            type = DataType()
            (
                <NULL> { nullable = true; }
            |
                <NOT> <NULL> { nullable = false; }
            |
                { nullable = true; }
            )
            (
                <DEFAULT_>
                defaultValue = Literal()
            |
                defaultValue = ArrayConstructor()
            |
                { defaultValue = null; }
            )
            (
                <BEFORE> { beforeColumn = SimpleIdentifier(); afterColumn = null; }
            |
                <AFTER> { afterColumn = SimpleIdentifier(); beforeColumn = null; }
            |
                { afterColumn = null; beforeColumn = null; }
            )
            {
                return new SqlAlterTableAddColumn(s.end(this), entity, name, type, nullable, defaultValue, beforeColumn, afterColumn);
            }
        |
            <AS>
            physicalName = SimpleIdentifier()
            (
                <DEFAULT_>
                defaultValue = Literal()
            |
                defaultValue = ArrayConstructor()
            |
                { defaultValue = null; }
            )
            (
                <BEFORE> { beforeColumn = SimpleIdentifier(); afterColumn = null; }
            |
                <AFTER> { afterColumn = SimpleIdentifier(); beforeColumn = null; }
            |
                { afterColumn = null; beforeColumn = null; }
            )
            {
                return new SqlAlterSourceTableAddColumn(s.end(this), entity, name, physicalName, defaultValue, beforeColumn, afterColumn);
            }
        )
    |
        <DROP> <COLUMN>
        column = SimpleIdentifier()
        {
            return new SqlAlterTableDropColumn(s.end(this), entity, column);
        }
    |
        <ADD> <PRIMARY> <KEY>
        (
            columnList = ParenthesizedSimpleIdentifierList()
        |
            column = SimpleIdentifier()
            {
                columnList = new SqlNodeList(Arrays.asList( new SqlNode[]{ column }), s.end(this));
            }
        )
        {
            return new SqlAlterTableAddPrimaryKey(s.end(this), entity, columnList);
        }
    |
        <DROP> <PRIMARY> <KEY>
        {
            return new SqlAlterTableDropPrimaryKey(s.end(this), entity);
        }
    |
        <ADD> <CONSTRAINT>
        constraintName = SimpleIdentifier()
        (
            <UNIQUE>
            (
                columnList = ParenthesizedSimpleIdentifierList()
            |
                column = SimpleIdentifier()
                {
                    columnList = new SqlNodeList(Arrays.asList( new SqlNode[]{ column }), s.end(this));
                }
            )
            {
                return new SqlAlterTableAddUniqueConstraint(s.end(this), entity, constraintName, columnList);
            }
        |
            <FOREIGN> <KEY>
            (
                columnList = ParenthesizedSimpleIdentifierList()
            |
                column = SimpleIdentifier()
                {
                    columnList = new SqlNodeList(Arrays.asList( new SqlNode[]{ column }), s.end(this));
                }
            )
            <REFERENCES>
            refTable = CompoundIdentifier()
            referencesList = ParenthesizedSimpleIdentifierList()
            (
                <ON> <UPDATE>
                (
                    <CASCADE> { onUpdate = "CASCADE"; }
                |
                    <NONE> { onUpdate = "NONE"; }
                |
                    <RESTRICT> { onUpdate = "RESTRICT"; }
                |
                    <SET> <NULL> { onUpdate = "SET NULL"; }
                |
                    <SET> <DEFAULT_> { onUpdate = "SET DEFAULT"; }
                )
            |
                { onUpdate = null; }
            )
            (
                <ON> <DELETE>
                (
                    <CASCADE> { onDelete = "CASCADE"; }
                |
                    <NONE> { onDelete = "NONE"; }
                |
                    <RESTRICT> { onDelete = "RESTRICT"; }
                |
                    <SET> <NULL> { onDelete = "SET NULL"; }
                |
                    <SET> <DEFAULT_> { onDelete = "SET DEFAULT"; }
                )
            |
                { onDelete = null; }
            )
            {
                return new SqlAlterTableAddForeignKey(s.end(this), entity, constraintName, columnList, refTable, referencesList, onUpdate, onDelete);
            }
        )
    |
        <DROP> <CONSTRAINT>
        constraintName = SimpleIdentifier()
        {
            return new SqlAlterTableDropConstraint(s.end(this), entity, constraintName);
        }
    |
        <DROP>
        <FOREIGN>
        <KEY>
        constraintName = SimpleIdentifier()
        {
            return new SqlAlterTableDropForeignKey(s.end(this), entity, constraintName);
        }
    |
        <ADD>
        <PLACEMENT>
        (
            (
                columnList = ParenthesizedSimpleIdentifierList()
            |
                column = SimpleIdentifier()
                {
                    columnList = new SqlNodeList(Arrays.asList( new SqlNode[]{ column }), s.end(this));
                }
            )
        |
            {
                columnList = SqlNodeList.EMPTY;
            }
        )
        <ON>
        <STORE>
        store = SimpleIdentifier()
            [
                <WITH> <PARTITIONS>
                <LPAREN>
                (
                        partitionIndex = UnsignedIntLiteral() { partitionList.add(partitionIndex); }
                        (
                            <COMMA> partitionIndex = UnsignedIntLiteral() { partitionList.add(partitionIndex); }
                        )*
                    |
                        partitionName = SimpleIdentifier() { partitionNamesList.add(partitionName); }
                        (
                            <COMMA> partitionName = SimpleIdentifier() { partitionNamesList.add(partitionName); }
                        )*
                )
                <RPAREN>
            ]
        {
            return new SqlAlterTableAddPlacement(s.end(this), entity, columnList, store, partitionList, partitionNamesList);
        }
    |
        <DROP>
        <PLACEMENT>
        <ON>
        <STORE>
        store = SimpleIdentifier()
        {
            return new SqlAlterTableDropPlacement(s.end(this), entity, store);
        }
    |
        <MODIFY>
        <PLACEMENT>
        (
            <ADD>
            <COLUMN>
            column = SimpleIdentifier()
            <ON>
            <STORE>
            store = SimpleIdentifier()
            {
                return new SqlAlterTableModifyPlacementAddColumn(s.end(this), entity, column, store);
            }
        |
            <DROP>
            <COLUMN>
            column = SimpleIdentifier()
            <ON>
            <STORE>
            store = SimpleIdentifier()
            {
                return new SqlAlterTableModifyPlacementDropColumn(s.end(this), entity, column, store);
            }
        |
            columnList = ParenthesizedSimpleIdentifierList()
            <ON>
            <STORE>
            store = SimpleIdentifier()
            [
                <WITH> <PARTITIONS>
                <LPAREN>
                (
                        partitionIndex = UnsignedIntLiteral() { partitionList.add(partitionIndex); }
                        (
                            <COMMA> partitionIndex = UnsignedIntLiteral() { partitionList.add(partitionIndex); }
                        )*
                    |

                        partitionName = SimpleIdentifier() { partitionNamesList.add(partitionName); }
                        (
                            <COMMA> partitionName = SimpleIdentifier() { partitionNamesList.add(partitionName); }
                        )*
               )
               <RPAREN>
            ]
            {
                return new SqlAlterTableModifyPlacement(s.end(this), entity, columnList, store, partitionList, partitionNamesList);
            }
        )

    |
        <MODIFY>
        <PARTITIONS>
        <LPAREN>
            (
                    partitionIndex = UnsignedIntLiteral() { partitionList.add(partitionIndex); }
                    (
                        <COMMA> partitionIndex = UnsignedIntLiteral() { partitionList.add(partitionIndex); }
                    )*
                |

                    partitionName = SimpleIdentifier() { partitionNamesList.add(partitionName); }
                    (
                         <COMMA> partitionName = SimpleIdentifier() { partitionNamesList.add(partitionName); }
                    )*
            )
        <RPAREN>
        <ON>
        <STORE> store = SimpleIdentifier()
        {
            return new SqlAlterTableModifyPartitions(s.end(this), entity, store, partitionList, partitionNamesList);
        }

    |
        <ADD>
        (
            <UNIQUE> { unique = true; }
        |
            { unique = false; }
        )
        <INDEX>
        indexName = SimpleIdentifier()
        <ON>
        (
            columnList = ParenthesizedSimpleIdentifierList()
        |
            column = SimpleIdentifier()
            {
                columnList = new SqlNodeList(Arrays.asList( new SqlNode[]{ column }), s.end(this));
            }
        )
        (
            <USING> indexMethod = SimpleIdentifier()
        |
            { indexMethod = null; }
        )
        (
            <ON> <STORE> storeName = SimpleIdentifier()
        |
            { storeName = null; }
        )
        {
            return new SqlAlterTableAddIndex(s.end(this), entity, columnList, unique, indexMethod, indexName, storeName);
        }
    |
        <DROP> <INDEX>
        indexName = SimpleIdentifier()
        {
            return new SqlAlterTableDropIndex(s.end(this), entity, indexName);
        }
    |
        <MODIFY> <COLUMN>
        column = SimpleIdentifier()
        statement = AlterTableModifyColumn(s, entity, column)
        {
            return statement;
        }

    |
        <PARTITION> <BY>
                    (
                            partitionType = SimpleIdentifier()
                        |
                            <RANGE> { partitionType = new SqlIdentifier( "RANGE", s.end(this) );}

                        |
                            <TEMPERATURE> { partitionType = new SqlIdentifier( "TEMPERATURE", s.end(this) );
                                    rawPartitionInfo = new RawTemperaturePartitionInformation();
                                    rawPartitionInfo.setPartitionType( partitionType );
                                    }
                                    <LPAREN> partitionColumn = SimpleIdentifier() { rawPartitionInfo.setPartitionColumn( partitionColumn ); } <RPAREN>
                                    <LPAREN>
                                        <PARTITION> partitionName = SimpleIdentifier() { partitionNamesList.add(partitionName); }
                                                <VALUES> <LPAREN>
                                                            partitionValues = Literal()
                                                            {
                                                                 partitionQualifiers.add(partitionValues);
                                                                 ((RawTemperaturePartitionInformation)rawPartitionInfo).setHotAccessPercentageIn( partitionValues );
                                                            } <PERCENT_REMAINDER>
                                                <RPAREN> {partitionQualifierList.add(partitionQualifiers); partitionQualifiers = new ArrayList<SqlNode>();}
                                        <COMMA>
                                        <PARTITION> partitionName = SimpleIdentifier() { partitionNamesList.add(partitionName); }
                                                <VALUES> <LPAREN>
                                                            partitionValues = Literal()
                                                            {
                                                                partitionQualifiers.add(partitionValues);
                                                                ((RawTemperaturePartitionInformation)rawPartitionInfo).setHotAccessPercentageOut( partitionValues );
                                                            } <PERCENT_REMAINDER>
                                                    <RPAREN> {partitionQualifierList.add(partitionQualifiers); partitionQualifiers = new ArrayList<SqlNode>();}
                                                    <RPAREN>
                                                        <USING> <FREQUENCY>
                                                                (
                                                                    <ALL> { ((RawTemperaturePartitionInformation)rawPartitionInfo).setAccessPattern( new SqlIdentifier( "ALL", s.end(this) ) ); tmpIdent = null; }
                                                                |
                                                                    <WRITE> { ((RawTemperaturePartitionInformation)rawPartitionInfo).setAccessPattern( new SqlIdentifier( "WRITE", s.end(this) ) ); tmpIdent = null; }
                                                                |
                                                                    <READ> { ((RawTemperaturePartitionInformation)rawPartitionInfo).setAccessPattern( new SqlIdentifier( "READ", s.end(this) ) ); tmpIdent = null;}
                                                                )
                                                            <INTERVAL>
                                                                    tmpInt = UnsignedIntLiteral() { ((RawTemperaturePartitionInformation)rawPartitionInfo).setInterval( tmpInt ); tmpInt = 0; }
                                                                    tmpIdent = SimpleIdentifier() { ((RawTemperaturePartitionInformation)rawPartitionInfo).setIntervalUnit( tmpIdent ); tmpIdent = null; }
                                                        <WITH>  numPartitions = UnsignedIntLiteral() {rawPartitionInfo.setNumPartitions( numPartitions );}
                                                                    tmpIdent = SimpleIdentifier() {
                                                                    ((RawTemperaturePartitionInformation)rawPartitionInfo).setInternalPartitionFunction( tmpIdent ); tmpIdent = null;
                                                            } <PARTITIONS>
                                                                    {
                                                                    rawPartitionInfo.setPartitionNamesList( CoreUtil.toNodeList( partitionNamesList, Identifier.class ) );
                                                                    rawPartitionInfo.setPartitionQualifierList( SqlUtil.toNodeListList( partitionQualifierList ) );

                                                                return new SqlAlterTableAddPartitions(s.end(this), entity, partitionColumn, partitionType, numPartitionGroups, numPartitions, partitionNamesList, partitionQualifierList, rawPartitionInfo);
                                                                            }
                    )

        <LPAREN> partitionColumn = SimpleIdentifier() <RPAREN>
        [
                (
                        <PARTITIONS> numPartitionGroups = UnsignedIntLiteral()
                    |
                        <WITH> <LPAREN>
                                partitionName = SimpleIdentifier() { partitionNamesList.add(partitionName); }
                                (
                                    <COMMA> partitionName = SimpleIdentifier() { partitionNamesList.add(partitionName); }
                                )*
                        <RPAREN>

                    |
                            <LPAREN>
                                <PARTITION> partitionName = SimpleIdentifier() { partitionNamesList.add(partitionName); }
                                <VALUES> <LPAREN>
                                        partitionValues = Literal() { partitionQualifiers.add(partitionValues); }
                                        (
                                            <COMMA> partitionValues = Literal() { partitionQualifiers.add(partitionValues); }
                                        )*
                                <RPAREN> {partitionQualifierList.add(partitionQualifiers); partitionQualifiers = new ArrayList<SqlNode>();}
                                (
                                    <COMMA> <PARTITION> partitionName = SimpleIdentifier() { partitionNamesList.add(partitionName); }
                                            <VALUES> <LPAREN>
                                                    partitionValues = Literal() { partitionQualifiers.add(partitionValues); }
                                                    (
                                                        <COMMA> partitionValues = Literal() { partitionQualifiers.add(partitionValues); }
                                                    )*
                                            <RPAREN> {partitionQualifierList.add(partitionQualifiers); partitionQualifiers = new ArrayList<SqlNode>();}
                                )*
                            <RPAREN>
                )
        ]
        {
            rawPartitionInfo = new RawPartitionInformation();
            return new SqlAlterTableAddPartitions(s.end(this), entity, partitionColumn, partitionType, numPartitionGroups, numPartitions, partitionNamesList, partitionQualifierList, rawPartitionInfo);
        }

    |
        <MERGE> <PARTITIONS>
        {
            return new SqlAlterTableMergePartitions(s.end(this), entity);
        }
    )
}

/**
* Parses the MODIFY COLUMN part of an ALTER TABLE statement.
*/
SqlAlterTableModifyColumn AlterTableModifyColumn(Span s, SqlIdentifier entity, SqlIdentifier column) :
{
    SqlDataTypeSpec type = null;
    Boolean nullable = null;
    SqlIdentifier beforeColumn = null;
    SqlIdentifier afterColumn = null;
    SqlNode defaultValue = null;
    Boolean dropDefault = null;
    String collation = null;
}
{
    (
        <SET> <NOT> <NULL>
        { nullable = false; }
    |
        <DROP> <NOT> <NULL>
        { nullable = true; }
    |
        <SET> <TYPE>
        type = DataType()
    |
        <SET> <POSITION>
        (
            <BEFORE>
            beforeColumn = SimpleIdentifier()
        |
            <AFTER>
            afterColumn = SimpleIdentifier()
        )
    |
        <SET> <COLLATION>
        (
            <CASE> <SENSITIVE> { collation = "CASE SENSITIVE"; }
        |
            <CASE> <INSENSITIVE> { collation = "CASE INSENSITIVE"; }
        )
    |
        <SET><DEFAULT_> defaultValue = Expression(ExprContext.ACCEPT_NONCURSOR)
    |
        <DROP> <DEFAULT_> { dropDefault = true; }
    )
    {
        return new SqlAlterTableModifyColumn(s.end(this), entity, column, type, nullable, beforeColumn, afterColumn, collation, defaultValue, dropDefault);
    }
}


SqlAlterConfig SqlAlterConfig(Span s) :
{
    final SqlNode key;
    final SqlNode value;
}
{
    <CONFIG> key = Expression(ExprContext.ACCEPT_NONCURSOR)
    <SET> value = Expression(ExprContext.ACCEPT_NONCURSOR)
    {
        return new SqlAlterConfig(s.end(this), key, value);
    }
}


SqlAlterAdaptersAdd SqlAlterAdaptersAdd(Span s) :
{
    final SqlNode uniqueName;
    final SqlNode adapterName;
    final SqlNode adapterType;
    final SqlNode config;
}
{
    <ADAPTERS> <ADD> uniqueName = Expression(ExprContext.ACCEPT_NONCURSOR)
    <USING> adapterName = Expression(ExprContext.ACCEPT_NONCURSOR)
    <AS> adapterType = Expression(ExprContext.ACCEPT_NONCURSOR)
    <WITH> config = Expression(ExprContext.ACCEPT_NONCURSOR)
    {
        return new SqlAlterAdaptersAdd(s.end(this), uniqueName, adapterName, adapterType, config);
    }
}


SqlAlterAdaptersDrop SqlAlterAdaptersDrop(Span s) :
{
    final SqlNode uniqueName;
}
{
    <ADAPTERS> <DROP> uniqueName = Expression(ExprContext.ACCEPT_NONCURSOR)
    {
        return new SqlAlterAdaptersDrop(s.end(this), uniqueName);
    }
}


SqlAlterInterfacesAdd SqlAlterInterfacesAdd(Span s) :
{
    final SqlNode uniqueName;
    final SqlNode clazzName;
    final SqlNode config;
}
{
    <INTERFACES> <ADD> uniqueName = Expression(ExprContext.ACCEPT_NONCURSOR)
    <USING> clazzName = Expression(ExprContext.ACCEPT_NONCURSOR)
    <WITH> config = Expression(ExprContext.ACCEPT_NONCURSOR)
    {
        return new SqlAlterInterfacesAdd(s.end(this), uniqueName, clazzName, config);
    }
}


SqlAlterInterfacesDrop SqlAlterInterfacesDrop(Span s) :
{
    final SqlNode uniqueName;
}
{
    <INTERFACES> <DROP> uniqueName = Expression(ExprContext.ACCEPT_NONCURSOR)
    {
        return new SqlAlterInterfacesDrop(s.end(this), uniqueName);
    }
}


////////////////////////////////////
/////////////parserimpl end
////////////////////////////////////
/////////////ddlparser start

boolean IfNotExistsOpt() :
{
}
{
    <IF> <NOT> <EXISTS> { return true; }
    |
    { return false; }
}

boolean IfExistsOpt() :
{
}
{
    <IF> <EXISTS> { return true; }
    |
    { return false; }
}


SqlCreate SqlCreateNamespace(Span s, boolean replace) :
{
    final boolean ifNotExists;
    final SqlIdentifier id;
    final DataModel dataModel;
}
{
    (
        <RELATIONAL> { dataModel = DataModel.RELATIONAL; }
        |
        <DOCUMENT> { dataModel = DataModel.DOCUMENT; }
        |
        <GRAPH> { dataModel = DataModel.GRAPH; }
        |
        { dataModel = DataModel.RELATIONAL; }
    )
    (<NAMESPACE> | <SCHEMA>) ifNotExists = IfNotExistsOpt() id = CompoundIdentifier()
    {
    return SqlDdlNodes.createNamespace(s.end(this), replace, ifNotExists, id, dataModel);
}
}

SqlNodeList Options() :
{
    final Span s;
    final List
    <SqlNode> list = new ArrayList
    <SqlNode>();
}
{
    <OPTIONS> { s = span(); }
    <LPAREN>
    [
        Option(list)
        (
            <COMMA>
            Option(list)
        )*
    ]
    <RPAREN> {
        return new SqlNodeList(list, s.end(this));
    }
}

void Option(List<SqlNode> list) :
{
    final SqlIdentifier id;
    final SqlNode value;
}
{
    id = SimpleIdentifier()
    value = Literal() {
    list.add(id);
    list.add(value);
}
}

SqlNodeList TableElementList() :
{
    final Span s;
    final List
    <SqlNode> list = new ArrayList
    <SqlNode>();
}
{
    <LPAREN> { s = span(); }
    TableElement(list)
    (
        <COMMA> TableElement(list)
    )*
    <RPAREN> {
        return new SqlNodeList(list, s.end(this));
    }
}

void TableElement(List<SqlNode> list) :
{
    final SqlIdentifier id;
    final SqlDataTypeSpec type;
    final boolean nullable;
    final SqlNode e;
    final SqlNode constraint;
    SqlIdentifier name = null;
    final SqlNodeList columnList;
    final Span s = Span.of();
    final ColumnStrategy strategy;
    final String collation;
    SqlIdentifier refTable;
    SqlIdentifier refColumn;
}
{
    id = SimpleIdentifier()
    (
        type = DataType()
        (
            <NULL> { nullable = true; }
            |
            <NOT> <NULL> { nullable = false; }
            |
            { nullable = true; }
        )
        (
            [ <GENERATED> <ALWAYS> ]
            <AS> <LPAREN>
            e = Expression(ExprContext.ACCEPT_SUB_QUERY)
            <RPAREN>
            (
                    <VIRTUAL> { strategy = ColumnStrategy.VIRTUAL; }
                |
                    <STORED> { strategy = ColumnStrategy.STORED; }
                |
                    { strategy = ColumnStrategy.VIRTUAL; }
            )
            |
                <DEFAULT_> e = Expression(ExprContext.ACCEPT_SUB_QUERY) {
                    strategy = ColumnStrategy.DEFAULT;
                }
            |
                {
                    e = null;
                    strategy = nullable ? ColumnStrategy.NULLABLE : ColumnStrategy.NOT_NULLABLE;
                }
        )
        (
                <COLLATE>
                (
                    <CASE> <SENSITIVE> { collation = "CASE SENSITIVE"; }
                    |
                    <CASE> <INSENSITIVE> { collation = "CASE INSENSITIVE"; }
                )
            |
                {
                  collation = null;
                }
        )
        {
            list.add( SqlDdlNodes.column(s.add(id).end(this), id, type.withNullable(nullable), collation, e, strategy));
        }
        |
            { list.add(id); }
    )
    |
        id = SimpleIdentifier() {
            list.add(id);
        }
    |
        [ <CONSTRAINT> { s.add(this); } name = SimpleIdentifier() ]
        (
            <CHECK> { s.add(this); }
            <LPAREN>
            e = Expression(ExprContext.ACCEPT_SUB_QUERY)
            <RPAREN> {
                list.add(SqlDdlNodes.check(s.end(this), name, e));
            }
            |
                <UNIQUE> { s.add(this); }
                columnList = ParenthesizedSimpleIdentifierList() {
                    list.add(SqlDdlNodes.unique(s.end(columnList), name, columnList));
                }
            |
                <PRIMARY> { s.add(this); }
                <KEY>
                columnList = ParenthesizedSimpleIdentifierList() {
                    list.add(SqlDdlNodes.primary(s.end(columnList), name, columnList));
                }
            |
                <FOREIGN> { s.add(this); }
                <KEY>
                columnList = ParenthesizedSimpleIdentifierList()
                <REFERENCES> {
                    s.add(this);
                }
                refTable = CompoundIdentifier()
                <LPAREN>
                refColumn = SimpleIdentifier()
                <RPAREN> {
                    list.add(SqlDdlNodes.foreign(s.end(this), name, columnList, refTable, refColumn));
                }
        )
}

SqlNodeList AttributeDefList() :
{
    final Span s;
    final List
    <SqlNode> list = new ArrayList<SqlNode>();
}
{
    <LPAREN> { s = span(); }
    AttributeDef(list)
    (
        <COMMA> AttributeDef(list)
    )*
    <RPAREN> {
        return new SqlNodeList(list, s.end(this));
    }
}

void AttributeDef(List<SqlNode> list) :
{
    final SqlIdentifier id;
    final SqlDataTypeSpec type;
    final boolean nullable;
    SqlNode e = null;
    final Span s = Span.of();
}
{
    id = SimpleIdentifier()
    (
        type = DataType()
        (
                <NULL> { nullable = true; }
            |
                <NOT> <NULL> { nullable = false; }
            |
                { nullable = true; }
            )
        )
    [ <DEFAULT_> e = Expression(ExprContext.ACCEPT_SUB_QUERY) ]
    {
        list.add(SqlDdlNodes.attribute(s.add(id).end(this), id,
        type.withNullable(nullable), e, null));
    }
}

SqlCreate SqlCreateType(Span s, boolean replace) :
{
    final SqlIdentifier id;
    SqlNodeList attributeDefList = null;
    SqlDataTypeSpec type = null;
}
{
    <TYPE>
    id = CompoundIdentifier()
    <AS>
    (
        attributeDefList = AttributeDefList()
        |
        type = DataType()
    )
    {
        return SqlDdlNodes.createType(s.end(this), replace, id, attributeDefList, type);
    }
}

SqlCreate SqlCreateTable(Span s, boolean replace) :
{
    final boolean ifNotExists;
    final SqlIdentifier id;
    SqlNodeList tableElementList = null;
    SqlNode query = null;
    SqlIdentifier store = null;
    SqlIdentifier partitionColumn = null;
    SqlIdentifier partitionType = null;
    int numPartitionGroups = 0;
    int numPartitions = 0;
    List<SqlIdentifier> partitionNamesList = new ArrayList<SqlIdentifier>();
    SqlIdentifier partitionName = null;
    List< List<SqlNode>> partitionQualifierList = new ArrayList<List<SqlNode>>();
    List<SqlNode> partitionQualifiers = new ArrayList<SqlNode>();
    SqlNode partitionValues = null;
    SqlIdentifier tmpIdent = null;
    int tmpInt = 0;
    RawPartitionInformation rawPartitionInfo;
}
{
    <TABLE> ifNotExists = IfNotExistsOpt() id = CompoundIdentifier()
    [ tableElementList = TableElementList() ]
    [ <AS> query = OrderedQueryOrExpr(ExprContext.ACCEPT_QUERY) ]
    [ <ON> <STORE> store = SimpleIdentifier() ]
    [ <PARTITION> <BY>
                       (
                                partitionType = SimpleIdentifier()
                            |
                                <RANGE> { partitionType = new SqlIdentifier( "RANGE", s.end(this) );}
                            |
                                <TEMPERATURE> { partitionType = new SqlIdentifier( "TEMPERATURE", s.end(this) );
                                    rawPartitionInfo = new RawTemperaturePartitionInformation();
                                    rawPartitionInfo.setPartitionType( partitionType );
                                    }
                                <LPAREN> partitionColumn = SimpleIdentifier() { rawPartitionInfo.setPartitionColumn( partitionColumn ); } <RPAREN>
                                        <LPAREN>
                                            <PARTITION> partitionName = SimpleIdentifier() { partitionNamesList.add(partitionName); }
                                                <VALUES> <LPAREN>
                                                            partitionValues = Literal()
                                                                {
                                                                    partitionQualifiers.add(partitionValues);
                                                                    ((RawTemperaturePartitionInformation)rawPartitionInfo).setHotAccessPercentageIn( partitionValues );
                                                                } <PERCENT_REMAINDER>
                                                        <RPAREN> {partitionQualifierList.add(partitionQualifiers); partitionQualifiers = new ArrayList<SqlNode>();}
                                                        <COMMA>
                                            <PARTITION> partitionName = SimpleIdentifier() { partitionNamesList.add(partitionName); }
                                                <VALUES> <LPAREN>
                                                        partitionValues = Literal()
                                                            {
                                                                partitionQualifiers.add(partitionValues);
                                                                ((RawTemperaturePartitionInformation)rawPartitionInfo).setHotAccessPercentageOut( partitionValues );
                                                            } <PERCENT_REMAINDER>
                                                <RPAREN> {partitionQualifierList.add(partitionQualifiers); partitionQualifiers = new ArrayList<SqlNode>();}
                                        <RPAREN>
                                            <USING> <FREQUENCY>

                                                        (
                                                            <ALL> { ((RawTemperaturePartitionInformation)rawPartitionInfo).setAccessPattern( new SqlIdentifier( "ALL", s.end(this) ) ); tmpIdent = null; }
                                                        |
                                                            <WRITE> { ((RawTemperaturePartitionInformation)rawPartitionInfo).setAccessPattern( new SqlIdentifier( "WRITE", s.end(this) ) ); tmpIdent = null; }
                                                        |
                                                            <READ> { ((RawTemperaturePartitionInformation)rawPartitionInfo).setAccessPattern( new SqlIdentifier( "READ", s.end(this) ) ); tmpIdent = null;}
                                                        )
                                                    <INTERVAL>
                                                            tmpInt = UnsignedIntLiteral() { ((RawTemperaturePartitionInformation)rawPartitionInfo).setInterval( tmpInt ); tmpInt = 0; }
                                                            tmpIdent = SimpleIdentifier() { ((RawTemperaturePartitionInformation)rawPartitionInfo).setIntervalUnit( tmpIdent ); tmpIdent = null; }
                                            <WITH>  numPartitions = UnsignedIntLiteral() {rawPartitionInfo.setNumPartitions( numPartitions );}
                                                tmpIdent = SimpleIdentifier() {
                                                        ((RawTemperaturePartitionInformation)rawPartitionInfo).setInternalPartitionFunction( tmpIdent ); tmpIdent = null;
                                                } <PARTITIONS>
                                        {
                                            rawPartitionInfo.setPartitionNamesList( CoreUtil.toNodeList( partitionNamesList, Identifier.class ) );
                                            rawPartitionInfo.setPartitionQualifierList( SqlUtil.toNodeListList( partitionQualifierList ) );

                                            return SqlDdlNodes.createTable(s.end(this), replace, ifNotExists, id, tableElementList, query, store, partitionType, partitionColumn, numPartitionGroups, numPartitions, partitionNamesList, partitionQualifierList, rawPartitionInfo);
                                        }
                       )
        <LPAREN> partitionColumn = SimpleIdentifier() <RPAREN>
        [
            (
                    <PARTITIONS> numPartitionGroups = UnsignedIntLiteral()
                |
                    <WITH> <LPAREN>
                            partitionName = SimpleIdentifier() { partitionNamesList.add(partitionName); }
                            (
                                <COMMA> partitionName = SimpleIdentifier() { partitionNamesList.add(partitionName); }
                            )*
                    <RPAREN>
                |
                    <LPAREN>
                        <PARTITION> partitionName = SimpleIdentifier() { partitionNamesList.add(partitionName); }
                        <VALUES> <LPAREN>
                                partitionValues = Literal() { partitionQualifiers.add(partitionValues); }
                                (
                                    <COMMA> partitionValues = Literal() { partitionQualifiers.add(partitionValues); }
                                )*
                        <RPAREN> {partitionQualifierList.add(partitionQualifiers); partitionQualifiers = new ArrayList<SqlNode>();}
                        (
                                <COMMA> <PARTITION> partitionName = SimpleIdentifier() { partitionNamesList.add(partitionName); }
                                        <VALUES> <LPAREN>
                                                partitionValues = Literal() { partitionQualifiers.add(partitionValues); }
                                                (
                                                    <COMMA> partitionValues = Literal() { partitionQualifiers.add(partitionValues); }
                                                )*
                                        <RPAREN> {partitionQualifierList.add(partitionQualifiers); partitionQualifiers = new ArrayList<SqlNode>();}
                        )*
                    <RPAREN>

            )

        ]
    ]
    {
        rawPartitionInfo = new RawPartitionInformation();
        return SqlDdlNodes.createTable(s.end(this), replace, ifNotExists, id, tableElementList, query, store, partitionType, partitionColumn, numPartitionGroups, numPartitions, partitionNamesList, partitionQualifierList, rawPartitionInfo);
    }
}

SqlCreate SqlCreateView(Span s, boolean replace) :
{
    final SqlIdentifier id;
    SqlNodeList columnList = null;
    final SqlNode query;
}
{
    <VIEW> id = CompoundIdentifier()
    [ columnList = ParenthesizedSimpleIdentifierList() ]
    <AS> query = OrderedQueryOrExpr(ExprContext.ACCEPT_QUERY) {
        return SqlDdlNodes.createView(s.end(this), replace, id, columnList, query);
    }
}

SqlCreate SqlCreateMaterializedView(Span s, boolean replace) :
{
    final SqlIdentifier id;
    final boolean ifNotExists;
    SqlNodeList columnList = null;
    final SqlNode query;
    SqlIdentifier storeName = null;
    List<SqlIdentifier>  store = new ArrayList<SqlIdentifier>();
    String freshnessType = null;
    Integer time = null;
    SqlIdentifier freshnessId = null;
}
{
    <MATERIALIZED><VIEW> ifNotExists = IfNotExistsOpt() id = CompoundIdentifier()
    [ columnList = ParenthesizedSimpleIdentifierList() ]
    <AS> query = OrderedQueryOrExpr(ExprContext.ACCEPT_QUERY)
    [ <ON> <STORE> storeName = SimpleIdentifier() { store.add(storeName); }
                (
                <COMMA> storeName = SimpleIdentifier() { store.add(storeName); }
                    )*]
    [ <FRESHNESS>
                    (
                        (<INTERVAL> time=UnsignedIntLiteral() freshnessId=CompoundIdentifier())
                            {
                                freshnessType="INTERVAL";
                            }
                        |
                        (<UPDATE> time=UnsignedIntLiteral())
                            {
                                freshnessType="UPDATE";
                            }
                        |(<MANUAL>)
                            {
                                freshnessType="MANUEL";
                            }
                    ) ]{
        return SqlDdlNodes.createMaterializedView(s.end(this), replace, ifNotExists, id, columnList, query, store, freshnessType, time, freshnessId);
    }
}

private void FunctionJarDef(SqlNodeList usingList) :
{
    final SqlDdlNodes.FileType fileType;
    final SqlNode uri;
}
{
    (
            <ARCHIVE> { fileType = SqlDdlNodes.FileType.ARCHIVE; }
        |
            <FILE> { fileType = SqlDdlNodes.FileType.FILE; }
        |
            <JAR> { fileType = SqlDdlNodes.FileType.JAR; }
    ) {
        usingList.add(SqlLiteral.createSymbol(fileType, getPos()));
    }
    uri = StringLiteral() {
        usingList.add(uri);
    }
}

SqlCreate SqlCreateFunction(Span s, boolean replace) :
{
    final boolean ifNotExists;
    final SqlIdentifier id;
    final SqlNode className;
    SqlNodeList usingList = SqlNodeList.EMPTY;
}
{
    <FUNCTION> ifNotExists = IfNotExistsOpt()
    id = CompoundIdentifier()
    <AS>
    className = StringLiteral()
    [
        <USING> {
            usingList = new SqlNodeList(getPos());
        }
        FunctionJarDef(usingList)
        (
            <COMMA>
            FunctionJarDef(usingList)
        )*
    ] {
        return SqlDdlNodes.createFunction(s.end(this), replace, ifNotExists, id, className, usingList);
    }
}

SqlDrop SqlDropNamespace(Span s, boolean replace) :
{
    final boolean ifExists;
    final SqlIdentifier id;
}
{
    (<NAMESPACE>|<SCHEMA>) ifExists = IfExistsOpt() id = CompoundIdentifier() {
        return SqlDdlNodes.dropNamespace(s.end(this), ifExists, id);
    }
}

SqlDrop SqlDropType(Span s, boolean replace) :
{
    final boolean ifExists;
    final SqlIdentifier id;
}
{
    <TYPE> ifExists = IfExistsOpt() id = CompoundIdentifier() {
        return SqlDdlNodes.dropType(s.end(this), ifExists, id);
    }
}

SqlDrop SqlDropTable(Span s, boolean replace) :
{
    final boolean ifExists;
    final SqlIdentifier id;
}
{
    <TABLE> ifExists = IfExistsOpt() id = CompoundIdentifier() {
        return SqlDdlNodes.dropTable(s.end(this), ifExists, id);
    }
}

SqlDrop SqlDropView(Span s, boolean replace) :
{
    final boolean ifExists;
    final SqlIdentifier id;
}
{
    <VIEW> ifExists = IfExistsOpt() id = CompoundIdentifier() {
        return SqlDdlNodes.dropView(s.end(this), ifExists, id);
    }
}

SqlDrop SqlDropMaterializedView(Span s, boolean replace) :
{
    final boolean ifExists;
    final SqlIdentifier id;
}
{
    <MATERIALIZED><VIEW> ifExists = IfExistsOpt() id = CompoundIdentifier() {
    return SqlDdlNodes.dropMaterializedView(s.end(this), ifExists, id);
    }
}

SqlDrop SqlDropFunction(Span s, boolean replace) :
{
    final boolean ifExists;
    final SqlIdentifier id;
}
{
    <FUNCTION> ifExists = IfExistsOpt()
    id = CompoundIdentifier() {
        return SqlDdlNodes.dropFunction(s.end(this), ifExists, id);
    }
}

////////////////////////////////////
/////////////ddlparser end


/**
 * Parses a leaf SELECT expression without ORDER BY.
 */
SqlSelect SqlSelect() :
{
    final List<SqlLiteral> keywords = new ArrayList<SqlLiteral>();
    final SqlNodeList keywordList;
    List<SqlNode> selectList;
    final SqlNode fromClause;
    final SqlNode where;
    final SqlNodeList groupBy;
    final SqlNode having;
    final SqlNodeList windowDecls;
    final Span s;
}
{
    <SELECT>
    {
        s = span();
    }
    SqlSelectKeywords(keywords)
    (
        <STREAM> {
            keywords.add(SqlLiteral.createSymbol(SqlSelectKeyword.STREAM, getPos()));
        }
    )?
    (
        <DISTINCT> {
            keywords.add(SqlLiteral.createSymbol(SqlSelectKeyword.DISTINCT, getPos()));
        }
    |   <ALL> {
            keywords.add(SqlLiteral.createSymbol(SqlSelectKeyword.ALL, getPos()));
        }
    )?
    {
        keywordList = new SqlNodeList(keywords, s.addAll(keywords).pos());
    }
    selectList = SelectList()
    (
        <FROM> fromClause = FromClause()
        where = WhereOpt()
        groupBy = GroupByOpt()
        having = HavingOpt()
        windowDecls = WindowOpt()
    |
        E() {
            fromClause = null;
            where = null;
            groupBy = null;
            having = null;
            windowDecls = null;
        }
    )
    {
        return new SqlSelect(s.end(this), keywordList,
            new SqlNodeList(selectList, Span.of(selectList).pos()),
            fromClause, where, groupBy, having, windowDecls, null, null, null);
    }
}

/*
 * Abstract production:
 *
 *    void SqlSelectKeywords(List keywords)
 *
 * Parses dialect-specific keywords immediately following the SELECT keyword.
 */

/**
 * Parses an EXPLAIN PLAN statement.
 */
SqlNode Explain() :
{
    SqlNode stmt;
    ExplainLevel detailLevel = ExplainLevel.EXPPLAN_ATTRIBUTES;
    Explain.Depth depth;
    final ExplainFormat format;
}
{
    <EXPLAIN> <PLAN>
    [ detailLevel = ExplainDetailLevel() ]
    depth = ExplainDepth()
    (
        <AS> <XML> { format = ExplainFormat.XML; }
    |
        <AS> <JSON> { format = ExplainFormat.JSON; }
    |
        { format = ExplainFormat.TEXT; }
    )
    <FOR> stmt = SqlQueryOrDml() {
        return new SqlExplain(getPos(),
            stmt,
            SqlLiteral.createSymbol(detailLevel, ParserPos.ZERO),
            SqlLiteral.createSymbol(depth, ParserPos.ZERO),
            SqlLiteral.createSymbol(format, ParserPos.ZERO),
            nDynamicParams);
    }
}

/** Parses a query (SELECT or VALUES)
 * or DML statement (INSERT, UPDATE, DELETE, MERGE). */
SqlNode SqlQueryOrDml() :
{
    SqlNode stmt;
}
{
    (
        stmt = OrderedQueryOrExpr(ExprContext.ACCEPT_QUERY)
    |
        stmt = SqlInsert()
    |
        stmt = SqlDelete()
    |
        stmt = SqlUpdate()
    |
        stmt = SqlMerge()
    ) { return stmt; }
}

/**
 * Parses WITH TYPE | WITH IMPLEMENTATION | WITHOUT IMPLEMENTATION modifier for
 * EXPLAIN PLAN.
 */
Explain.Depth ExplainDepth() :
{
}
{
    (
        LOOKAHEAD(2)
        <WITH> <TYPE>
        {
            return Explain.Depth.TYPE;
        }
        |
        <WITH> <IMPLEMENTATION>
        {
            return Explain.Depth.PHYSICAL;
        }
        |
        <WITHOUT> <IMPLEMENTATION>
        {
            return Explain.Depth.LOGICAL;
        }
        |
        {
            return Explain.Depth.PHYSICAL;
        }

    )
}

/**
 * Parses INCLUDING ALL ATTRIBUTES modifier for EXPLAIN PLAN.
 */
ExplainLevel ExplainDetailLevel() :
{
    ExplainLevel level = ExplainLevel.EXPPLAN_ATTRIBUTES;
}
{
    (
        <EXCLUDING> <ATTRIBUTES>
        {
            level = ExplainLevel.NO_ATTRIBUTES;
        }
        |
        <INCLUDING>
        [ <ALL> { level = ExplainLevel.ALL_ATTRIBUTES; } ]
        <ATTRIBUTES>
        {
        }
    )
    {
        return level;
    }
}

/**
 * Parses a DESCRIBE statement.
 */
SqlNode SqlDescribe() :
{
   final Span s;
   final SqlIdentifier table;
   final SqlIdentifier column;
   final SqlIdentifier id;
   final SqlNode stmt;
}
{
    <DESCRIBE> { s = span(); }
    (
        (<DATABASE> | <CATALOG> | <SCHEMA> | <NAMESPACE>)
        id = CompoundIdentifier() {
            // DESCRIBE DATABASE and DESCRIBE CATALOG currently do the same as
            // DESCRIBE NAMESPACE but should be different. See
            //   [POLYPHENYDB-1221] Implement DESCRIBE DATABASE, CATALOG, STATEMENT
            return new SqlDescribeNamespace(s.end(id), id);
        }
    |
        // Use syntactic lookahead to determine whether a table name is coming.
        // We do not allow SimpleIdentifier() because that includes <STATEMENT>.
        LOOKAHEAD( <TABLE> | <IDENTIFIER> | <QUOTED_IDENTIFIER> | <BACK_QUOTED_IDENTIFIER> | <BRACKET_QUOTED_IDENTIFIER> )
        (<TABLE>)?
        table = CompoundIdentifier()
        (
            column = SimpleIdentifier()
        |
            E() { column = null; }
        ) {
            return new SqlDescribeTable(s.add(table).addIf(column).pos(), table, column);
        }
    |
        (<STATEMENT>)?
        stmt = SqlQueryOrDml() {
            // DESCRIBE STATEMENT currently does the same as EXPLAIN. See
            //   [POLYPHENYDB-1221] Implement DESCRIBE DATABASE, CATALOG, STATEMENT
            final ExplainLevel detailLevel = ExplainLevel.EXPPLAN_ATTRIBUTES;
            final Explain.Depth depth = Explain.Depth.PHYSICAL;
            final ExplainFormat format = ExplainFormat.TEXT;
            return new SqlExplain(s.end(stmt),
                stmt,
                SqlLiteral.createSymbol(detailLevel, ParserPos.ZERO),
                SqlLiteral.createSymbol(depth, ParserPos.ZERO),
                SqlLiteral.createSymbol(format, ParserPos.ZERO),
                nDynamicParams);
        }
    )
}

/**
 * Parses a CALL statement.
 */
SqlNode SqlProcedureCall() :
{
    final Span s;
    SqlNode routineCall;
}
{
    <CALL> {
        s = span();
    }
    routineCall = NamedRoutineCall(FunctionCategory.USER_DEFINED_PROCEDURE, ExprContext.ACCEPT_SUB_QUERY)
    {
        return (SqlCall) OperatorRegistry.get( OperatorName.PROCEDURE_CALL ).createCall(s.end(routineCall), routineCall);
    }
}

SqlNode NamedRoutineCall(FunctionCategory routineType, ExprContext exprContext) :
{
    SqlIdentifier name;
    final List<SqlNode> list = new ArrayList<SqlNode>();
    final Span s;
}
{
    name = CompoundIdentifier() {
        s = span();
    }
    <LPAREN>
    [
        Arg0(list, exprContext)
        (
            <COMMA> {
                // a comma-list can't appear where only a query is expected
                checkNonQueryExpression(exprContext);
            }
            Arg(list, exprContext)
        )*
    ]
    <RPAREN>
    {
        return createCall(name, s.end(this), routineType, null, list);
    }
}

/**
 * Parses an INSERT statement.
 */
SqlNode SqlInsert() :
{
    final List<SqlLiteral> keywords = new ArrayList<SqlLiteral>();
    final SqlNodeList keywordList;
    SqlNode table;
    SqlNodeList extendList = null;
    SqlNode source;
    SqlNodeList columnList = null;
    final Span s;
}
{
    (
        <INSERT>
    |
        <UPSERT> { keywords.add(SqlLiteral.createSymbol(SqlInsertKeyword.UPSERT, getPos())); }
    )
    { s = span(); }
    SqlInsertKeywords(keywords) {
        keywordList = new SqlNodeList(keywords, s.addAll(keywords).pos());
    }
    <INTO> table = CompoundIdentifier()
    [
        LOOKAHEAD(5)
        [ <EXTEND> ]
        extendList = ExtendList() {
            table = extend(table, extendList);
        }
    ]
    [
        LOOKAHEAD(2)
        { final Pair<SqlNodeList, SqlNodeList> p; }
        p = ParenthesizedCompoundIdentifierList() {
            if (p.right.size() > 0) {
                table = extend(table, p.right);
            }
            if (p.left.size() > 0) {
                columnList = p.left;
            }
        }
    ]
    source = OrderedQueryOrExpr(ExprContext.ACCEPT_QUERY) {
        return new SqlInsert(s.end(source), keywordList, table, source, columnList);
    }
}

/*
 * Abstract production:
 *
 *    void SqlInsertKeywords(List keywords)
 *
 * Parses dialect-specific keywords immediately following the INSERT keyword.
 */

/**
 * Parses a DELETE statement.
 */
SqlNode SqlDelete() :
{
    SqlNode table;
    SqlNodeList extendList = null;
    SqlIdentifier alias = null;
    final SqlNode condition;
    final Span s;
}
{
    <DELETE> {
        s = span();
    }
    <FROM> table = CompoundIdentifier()
    [
        [ <EXTEND> ]
        extendList = ExtendList() {
            table = extend(table, extendList);
        }
    ]
    [ [ <AS> ] alias = SimpleIdentifier() ]
    condition = WhereOpt()
    {
        return new SqlDelete(s.add(table).addIf(extendList).addIf(alias).addIf(condition).pos(), table, condition, null, alias);
    }
}

/**
 * Parses an UPDATE statement.
 */
SqlNode SqlUpdate() :
{
    SqlNode table;
    SqlNodeList extendList = null;
    SqlIdentifier alias = null;
    SqlNode condition;
    SqlNodeList sourceExpressionList;
    SqlNodeList targetColumnList;
    SqlIdentifier id;
    SqlNode exp;
    final Span s;
}
{
    <UPDATE> { s = span(); }
    table = CompoundIdentifier() {
        targetColumnList = new SqlNodeList(s.pos());
        sourceExpressionList = new SqlNodeList(s.pos());
    }
    [
        [ <EXTEND> ]
        extendList = ExtendList() {
            table = extend(table, extendList);
        }
    ]
    [ [ <AS> ] alias = SimpleIdentifier() ]
    <SET> id = SimpleIdentifier() {
        targetColumnList.add(id);
    }
    <EQ> exp = Expression(ExprContext.ACCEPT_SUB_QUERY) {
        // TODO:  support DEFAULT also
        sourceExpressionList.add(exp);
    }
    (
        <COMMA>
        id = SimpleIdentifier()
        {
            targetColumnList.add(id);
        }
        <EQ> exp = Expression(ExprContext.ACCEPT_SUB_QUERY)
        {
            sourceExpressionList.add(exp);
        }
    )*
    condition = WhereOpt()
    {
        return new SqlUpdate(s.addAll(targetColumnList.getSqlList()).addAll(sourceExpressionList.getSqlList()).addIf(condition).pos(), table, targetColumnList, sourceExpressionList, condition, null, alias);
    }
}

/**
 * Parses a MERGE statement.
 */
SqlNode SqlMerge() :
{
    SqlNode table;
    SqlNodeList extendList = null;
    SqlIdentifier alias = null;
    SqlNode sourceTableRef;
    SqlNode condition;
    SqlUpdate updateCall = null;
    SqlInsert insertCall = null;
    final Span s;
}
{
    <MERGE> { s = span(); } <INTO> table = CompoundIdentifier()
    [
        [ <EXTEND> ]
        extendList = ExtendList() {
            table = extend(table, extendList);
        }
    ]
    [ [ <AS> ] alias = SimpleIdentifier() ]
    <USING> sourceTableRef = TableRef()
    <ON> condition = Expression(ExprContext.ACCEPT_SUB_QUERY)
    (
        LOOKAHEAD(2)
        updateCall = WhenMatchedClause(table, alias)
        [ insertCall = WhenNotMatchedClause(table) ]
    |
        insertCall = WhenNotMatchedClause(table)
    )
    {
        return new SqlMerge(s.addIf(updateCall).addIf(insertCall).pos(), table, condition, sourceTableRef, updateCall, insertCall, null, alias);
    }
}

SqlUpdate WhenMatchedClause(SqlNode table, SqlIdentifier alias) :
{
    SqlIdentifier id;
    final Span s;
    final SqlNodeList updateColumnList = new SqlNodeList(ParserPos.ZERO);
    SqlNode exp;
    final SqlNodeList updateExprList = new SqlNodeList(ParserPos.ZERO);
}
{
    <WHEN> { s = span(); } <MATCHED> <THEN>
    <UPDATE> <SET> id = SimpleIdentifier() {
        updateColumnList.add(id);
    }
    <EQ> exp = Expression(ExprContext.ACCEPT_SUB_QUERY) {
        updateExprList.add(exp);
    }
    (
        <COMMA>
        id = SimpleIdentifier() {
            updateColumnList.add(id);
        }
        <EQ> exp = Expression(ExprContext.ACCEPT_SUB_QUERY) {
            updateExprList.add(exp);
        }
    )*
    {
        return new SqlUpdate(s.addAll(updateExprList.getSqlList()).pos(), table, updateColumnList, updateExprList, null, null, alias);
    }
}

SqlInsert WhenNotMatchedClause(SqlNode table) :
{
    final Span insertSpan, valuesSpan;
    final List<SqlLiteral> keywords = new ArrayList<SqlLiteral>();
    final SqlNodeList keywordList;
    SqlNodeList insertColumnList = null;
    SqlNode rowConstructor;
    SqlNode insertValues;
}
{
    <WHEN> <NOT> <MATCHED> <THEN> <INSERT> {
        insertSpan = span();
    }
    SqlInsertKeywords(keywords) {
        keywordList = new SqlNodeList(keywords, insertSpan.end(this));
    }
    [
        LOOKAHEAD(2)
        insertColumnList = ParenthesizedSimpleIdentifierList()
    ]
    [ <LPAREN> ]
    <VALUES> { valuesSpan = span(); }
    rowConstructor = RowConstructor()
    [ <RPAREN> ]
    {
        // TODO zfong 5/26/06: note that extra parentheses are accepted above around the VALUES clause as a hack for unparse, but this is
        // actually invalid SQL; should fix unparse
        insertValues = (SqlCall) OperatorRegistry.get( OperatorName.VALUES ).createCall(valuesSpan.end(this), rowConstructor);
        return new SqlInsert(insertSpan.end(this), keywordList, table, insertValues, insertColumnList);
    }
}

/**
 * Parses the select list of a SELECT statement.
 */
List<SqlNode> SelectList() :
{
    final List<SqlNode> list = new ArrayList<SqlNode>();
    SqlNode item;
}
{
    item = SelectItem() {
        list.add(item);
    }
    (
        <COMMA> item = SelectItem() {
            list.add(item);
        }
    )*
    {
        return list;
    }
}

/**
 * Parses one item in a select list.
 */
SqlNode SelectItem() :
{
    SqlNode e;
    SqlIdentifier id;
}
{
    e = SelectExpression()
    [
        [ <AS> ]
        id = SimpleIdentifier() {
            e = (SqlCall) OperatorRegistry.get( OperatorName.AS ).createCall(span().end(e), e, id);
        }
    ]
    {
        return e;
    }
}

/**
 * Parses one unaliased expression in a select list.
 */
SqlNode SelectExpression() :
{
    SqlNode e;
}
{
    <STAR> {
        return SqlIdentifier.star(getPos());
    }
|
    e = Expression(ExprContext.ACCEPT_SUB_QUERY) {
        return e;
    }
}

SqlLiteral Natural() :
{
}
{
    <NATURAL> { return SqlLiteral.createBoolean(true, getPos()); }
|
    { return SqlLiteral.createBoolean(false, getPos()); }
}

SqlLiteral JoinType() :
{
    JoinType joinType;
}
{
    (
        <JOIN> { joinType = JoinType.INNER; }
    |
        <INNER> <JOIN> { joinType = JoinType.INNER; }
    |
        <LEFT> [ <OUTER> ] <JOIN> { joinType = JoinType.LEFT; }
    |
        <RIGHT> [ <OUTER> ] <JOIN> { joinType = JoinType.RIGHT; }
    |
        <FULL> [ <OUTER> ] <JOIN> { joinType = JoinType.FULL; }
    |
        <CROSS> <JOIN> { joinType = JoinType.CROSS; }
    )
    {
        return SqlLiteral.createSymbol(joinType, getPos());
    }
}

/** Matches "LEFT JOIN t ON ...", "RIGHT JOIN t USING ...", "JOIN t". */
SqlNode JoinTable(SqlNode e) :
{
    SqlNode e2, condition;
    final SqlLiteral natural, joinType, on, using;
    SqlNodeList list;
}
{
    natural = Natural()
    joinType = JoinType()
    e2 = TableRef()
    (
        <ON> { on = SqlLiteral.createSymbol(JoinConditionType.ON, getPos()); }
        condition = Expression(ExprContext.ACCEPT_SUB_QUERY) {
            return new SqlJoin(joinType.getPos(),
                e,
                natural,
                joinType,
                e2,
                on,
                condition);
        }
    |
        <USING> { using = SqlLiteral.createSymbol(JoinConditionType.USING, getPos()); }
        list = ParenthesizedSimpleIdentifierList() {
            return new SqlJoin(joinType.getPos(),
                e,
                natural,
                joinType,
                e2,
                using,
                new SqlNodeList(list.getSqlList(), Span.of(using).end(this)));
        }
    |
        {
            return new SqlJoin(joinType.getPos(),
                e,
                natural,
                joinType,
                e2,
                SqlLiteral.createSymbol(JoinConditionType.NONE, joinType.getPos()),
                null);
        }
    )
}

// TODO jvs 15-Nov-2003:  SQL standard allows parentheses in the FROM list for
// building up non-linear join trees (e.g. OUTER JOIN two tables, and then INNER
// JOIN the result).  Also note that aliases on parenthesized FROM expressions
// "hide" all table names inside the parentheses (without aliases, they're
// visible).
//
// We allow CROSS JOIN to have a join condition, even though that is not valid
// SQL; the validator will catch it.
/**
 * Parses the FROM clause for a SELECT.
 *
 * <p>FROM is mandatory in standard SQL, optional in dialects such as MySQL,
 * PostgreSQL. The parser allows SELECT without FROM, but the validator fails
 * if conformance is, say, STRICT_2003.
 */
SqlNode FromClause() :
{
    SqlNode e, e2, condition;
    SqlLiteral natural, joinType, joinConditionType;
    SqlNodeList list;
    ParserPos pos;
}
{
    e = TableRef()
    (
        // Decide whether to read a JOIN clause or a comma, or to quit having
        // seen a single entry FROM clause like 'FROM emps'. See comments
        // elsewhere regarding <COMMA> lookahead.
        LOOKAHEAD(2)
        natural = Natural()
        joinType = JoinType()
        e2 = TableRef()
        (
            <ON> {
                joinConditionType = SqlLiteral.createSymbol(JoinConditionType.ON, getPos());
            }
            condition = Expression(ExprContext.ACCEPT_SUB_QUERY) {
                e = new SqlJoin(joinType.getPos(),
                    e,
                    natural,
                    joinType,
                    e2,
                    joinConditionType,
                    condition);
            }
        |
            <USING> {
                joinConditionType = SqlLiteral.createSymbol(JoinConditionType.USING, getPos());
            }
            list = ParenthesizedSimpleIdentifierList() {
                e = new SqlJoin(joinType.getPos(),
                    e,
                    natural,
                    joinType,
                    e2,
                    joinConditionType,
                    new SqlNodeList(list.getSqlList(), Span.of(joinConditionType).end(this)));
            }
        |
            {
                e = new SqlJoin(joinType.getPos(),
                    e,
                    natural,
                    joinType,
                    e2,
                    SqlLiteral.createSymbol( JoinConditionType.NONE, joinType.getPos()),
                    null);
            }
        )
    |
        // NOTE jvs 6-Feb-2004:  See comments at top of file for why
        // hint is necessary here.  I had to use this special semantic
        // lookahead form to get JavaCC to shut up, which makes
        // me even more uneasy.
        //LOOKAHEAD({true})
        <COMMA> { joinType = SqlLiteral.createSymbol(JoinType.COMMA,getPos()); }
        e2 = TableRef() {
            e = new SqlJoin(joinType.getPos(),
                e,
                SqlLiteral.createBoolean(false, joinType.getPos()),
                joinType,
                e2,
                SqlLiteral.createSymbol(JoinConditionType.NONE, ParserPos.ZERO),
                null);
        }
    |
        <CROSS> { joinType = SqlLiteral.createSymbol(JoinType.CROSS, getPos()); } <APPLY>
        e2 = TableRef2(true) {
            if (!this.conformance.isApplyAllowed()) {
                throw new ParseException(RESOURCE.applyNotAllowed().str());
            }
            e = new SqlJoin(joinType.getPos(),
                e,
                SqlLiteral.createBoolean(false, joinType.getPos()),
                joinType,
                e2,
                SqlLiteral.createSymbol(JoinConditionType.NONE, ParserPos.ZERO),
                null);
        }
    |
        <OUTER> { joinType = SqlLiteral.createSymbol(JoinType.LEFT, getPos()); } <APPLY>
        e2 = TableRef2(true) {
            if (!this.conformance.isApplyAllowed()) {
                throw new ParseException(RESOURCE.applyNotAllowed().str());
            }
            e = new SqlJoin(joinType.getPos(),
                e,
                SqlLiteral.createBoolean(false, joinType.getPos()),
                joinType,
                e2,
                SqlLiteral.createSymbol(JoinConditionType.ON, ParserPos.ZERO),
                SqlLiteral.createBoolean(true, joinType.getPos()));
        }
    )*
    {
        return e;
    }
}

/**
 * Parses a table reference in a FROM clause, not lateral unless LATERAL
 * is explicitly specified.
 */
SqlNode TableRef() :
{
    final SqlNode e;
}
{
    e = TableRef2(false) { return e; }
}

/**
 * Parses a table reference in a FROM clause.
 */
SqlNode TableRef2(boolean lateral) :
{
    SqlNode tableRef;
    SqlNode over;
    SqlNodeList extendList = null;
    String alias;
    final SqlIdentifier id;
    final Span s, s2;
    SqlNodeList args;
    SqlNode sample;
    boolean isBernoulli;
    SqlNumericLiteral samplePercentage;
    boolean isRepeatable = false;
    int repeatableSeed = 0;
    SqlNodeList columnAliasList = null;
    SqlUnnestOperator unnestOp = OperatorRegistry.get( OperatorName.UNNEST, SqlUnnestOperator.class );
}
{
    (
        LOOKAHEAD(2)
        tableRef = CompoundIdentifier()
        [
            [ <EXTEND> ]
            extendList = ExtendList() {
                tableRef = extend(tableRef, extendList);
            }
        ]
        over = TableOverOpt()
        {
            if (over != null) {
                tableRef = (SqlCall) OperatorRegistry.get( OperatorName.OVER ).createCall(
                    getPos(), tableRef, over);
            }
        }
        [
            over = MatchRecognizeOpt(tableRef)
            {
                if (over != null) {
                    tableRef = over;
                }
            }
        ]
    |
        [ <LATERAL> { lateral = true; } ]
        tableRef = ParenthesizedExpression(ExprContext.ACCEPT_QUERY)
        over = TableOverOpt()
        {
            if (over != null) {
                tableRef = (SqlCall) OperatorRegistry.get( OperatorName.OVER ).createCall(
                    getPos(), tableRef, over);
            }
            if (lateral) {
                tableRef = (SqlCall) OperatorRegistry.get( OperatorName.LATERAL ).createCall(
                    getPos(), tableRef);
            }
        }
        (
            [ over = MatchRecognizeOpt(tableRef) ]
            {
                if (over != null) {
                    tableRef = over;
                }
            }
        )
    |
        <UNNEST> { s = span(); }
        args = ParenthesizedQueryOrCommaList(ExprContext.ACCEPT_SUB_QUERY)
        [
            <WITH> <ORDINALITY> {
                unnestOp = OperatorRegistry.get( OperatorName.UNNEST_WITH_ORDINALITY, SqlUnnestOperator.class );
            }
        ]
        {
            tableRef = (SqlCall) unnestOp.createCall(s.end(this), args.toArray());
        }
    |
        [ <LATERAL> { lateral = true; } ]
        <TABLE> { s = span(); } <LPAREN>
        tableRef = TableFunctionCall(s.pos())
        <RPAREN>
        {
            if (lateral) {
                tableRef = (SqlCall) OperatorRegistry.get( OperatorName.LATERAL ).createCall(
                    s.end(this), tableRef);
            }
        }
    |
        tableRef = ExtendedTableRef()
    )
    [
        [ <AS> ] alias = Identifier() {
            id = new SqlIdentifier(alias, getPos());
        }
        [ columnAliasList = ParenthesizedSimpleIdentifierList() ]
        {
            if (columnAliasList == null) {
                tableRef = (SqlCall) OperatorRegistry.get( OperatorName.AS ).createCall( Span.of(tableRef).end(this), tableRef, id );
            } else {
                List<SqlNode> idList = new ArrayList<SqlNode>();
                idList.add(tableRef);
                idList.add(id);
                idList.addAll(columnAliasList.getSqlList());
                tableRef = (SqlCall) OperatorRegistry.get( OperatorName.AS ).createCall( Span.of(tableRef).end(this), idList );
            }
        }
    ]
    [
        <TABLESAMPLE> { s2 = span(); }
        (
            <SUBSTITUTE> <LPAREN> sample = StringLiteral() <RPAREN>
            {
                String sampleName = SqlLiteral.unchain(sample).getValueAs(String.class);
                SqlSampleSpec sampleSpec = SqlSampleSpec.createNamed(sampleName);
                final SqlLiteral sampleLiteral = SqlLiteral.createSample(sampleSpec, s2.end(this));
                tableRef = (SqlCall) OperatorRegistry.get( OperatorName.TABLESAMPLE ).createCall(s2.add(tableRef).end(this), tableRef, sampleLiteral);
            }
        |
            (
                <BERNOULLI>
                {
                    isBernoulli = true;
                }
            |
                <SYSTEM>
                {
                    isBernoulli = false;
                }
            )
            <LPAREN> samplePercentage = UnsignedNumericLiteral() <RPAREN>
            [
                <REPEATABLE> <LPAREN> repeatableSeed = IntLiteral() <RPAREN>
                {
                    isRepeatable = true;
                }
            ]
            {
                final BigDecimal ONE_HUNDRED = BigDecimal.valueOf(100L);
                BigDecimal rate = samplePercentage.bigDecimalValue();
                if (rate.compareTo(BigDecimal.ZERO) < 0 || rate.compareTo(ONE_HUNDRED) > 0)
                {
                    throw new ParseException(RESOURCE.invalidSampleSize().str());
                }

                // Treat TABLESAMPLE(0) and TABLESAMPLE(100) as no table
                // sampling at all.  Not strictly correct: TABLESAMPLE(0)
                // should produce no output, but it simplifies implementation
                // to know that some amount of sampling will occur.
                // In practice values less than ~1E-43% are treated as 0.0 and
                // values greater than ~99.999997% are treated as 1.0
                float fRate = rate.divide(ONE_HUNDRED).floatValue();
                if (fRate > 0.0f && fRate < 1.0f) {
                    SqlSampleSpec tableSampleSpec =
                    isRepeatable
                        ? SqlSampleSpec.createTableSample(isBernoulli, fRate, repeatableSeed)
                        : SqlSampleSpec.createTableSample(isBernoulli, fRate);

                    SqlLiteral tableSampleLiteral = SqlLiteral.createSample(tableSampleSpec, s2.end(this));
                    tableRef = (SqlCall) OperatorRegistry.get( OperatorName.TABLESAMPLE ).createCall(s2.end(this), tableRef, tableSampleLiteral);
                }
            }
        )
    ]
    {
        return tableRef;
    }
}

SqlNodeList ExtendList() :
{
    final Span s;
    List<SqlNode> list = new ArrayList<SqlNode>();
}
{
    <LPAREN> { s = span(); }
    ColumnType(list)
    (
        <COMMA> ColumnType(list)
    )*
    <RPAREN> {
        return new SqlNodeList(list, s.end(this));
    }
}

void ColumnType(List<SqlNode> list) :
{
    SqlIdentifier name;
    SqlDataTypeSpec type;
    boolean nullable = true;
}
{
    name = CompoundIdentifier()
    type = DataType()
    [
        <NOT> <NULL> {
            nullable = false;
        }
    ]
    {
        list.add(name);
        list.add(type.withNullable(nullable));
    }
}

/**
 * Parses a compound identifier with optional type.
 */
void CompoundIdentifierType(List<SqlNode> list, List<SqlNode> extendList) :
{
    final SqlIdentifier name;
    SqlDataTypeSpec type = null;
    boolean nullable = true;
}
{
    name = CompoundIdentifier()
    [
        type = DataType() {
            if (!this.conformance.allowExtend()) {
                throw new ParseException(RESOURCE.extendNotAllowed().str());
            }
        }
        [
            <NOT> <NULL> {
                nullable = false;
            }
        ]
    ]
    {
       if (type != null) {
           extendList.add(name);
           extendList.add(type.withNullable(nullable));
       }
       list.add(name);
    }
}

SqlNode TableFunctionCall(ParserPos pos) :
{
    SqlNode call;
    FunctionCategory funcType = FunctionCategory.USER_DEFINED_TABLE_FUNCTION;
}
{
    [
        <SPECIFIC>
        {
            funcType = FunctionCategory.USER_DEFINED_TABLE_SPECIFIC_FUNCTION;
        }
    ]
    call = NamedRoutineCall(funcType, ExprContext.ACCEPT_CURSOR)
    {
        return (SqlCall) OperatorRegistry.get( OperatorName.COLLECTION_TABLE ).createCall(pos, call);
    }
}

/**
 * Abstract production:
 *    SqlNode ExtendedTableRef()
 *
 * <p>Allows parser to be extended with new types of table references.  The
 * default implementation of this production is empty.
 */

/*
 * Abstract production:
 *
 *    SqlNode TableOverOpt()
 *
 * Allows an OVER clause following a table expression as an extension to
 * standard SQL syntax. The default implementation of this production is empty.
 */

/**
 * Parses an explicit TABLE t reference.
 */
SqlNode ExplicitTable(ParserPos pos) :
{
    SqlNode tableRef;
}
{
    <TABLE> tableRef = CompoundIdentifier()
    {
        return (SqlCall) OperatorRegistry.get( OperatorName.EXPLICIT_TABLE ).createCall(pos, tableRef);
    }
}

/**
 * Parses a VALUES leaf query expression.
 */
SqlNode TableConstructor() :
{
    SqlNodeList rowConstructorList;
    final Span s;
}
{
    <VALUES> { s = span(); }
    rowConstructorList = RowConstructorList(s)
    {
        return (SqlCall) OperatorRegistry.get( OperatorName.VALUES ).createCall(s.end(this), rowConstructorList.toArray());
    }
}

/**
 * Parses one or more rows in a VALUES expression.
 */
SqlNodeList RowConstructorList(Span s) :
{
    List<SqlNode> list = new ArrayList<SqlNode>();
    SqlNode rowConstructor;
}
{
    rowConstructor = RowConstructor() { list.add(rowConstructor); }
    (
        LOOKAHEAD(2)
        <COMMA> rowConstructor = RowConstructor() { list.add(rowConstructor); }
    )*
    {
        return new SqlNodeList(list, s.end(this));
    }
}

/**
 * Parses a row constructor in the context of a VALUES expression.
 */
SqlNode RowConstructor() :
{
    SqlNodeList valueList;
    SqlNode value;
    final Span s;
}
{
    // hints are necessary here due to common LPAREN prefixes
    (
        // TODO jvs 8-Feb-2004: extra parentheses are accepted here as a hack
        // for unparse, but this is actually invalid SQL; should
        // fix unparse
        LOOKAHEAD(3)
        <LPAREN> { s = span(); }
        <ROW>
        valueList = ParenthesizedQueryOrCommaListWithDefault(ExprContext.ACCEPT_NONCURSOR)
        <RPAREN> { s.add(this); }
    |
        LOOKAHEAD(3)
        (
            <ROW> { s = span(); }
        |
            { s = Span.of(); }
        )
        valueList = ParenthesizedQueryOrCommaListWithDefault(ExprContext.ACCEPT_NONCURSOR)
    |
        value = Expression(ExprContext.ACCEPT_NONCURSOR)
        {
            // NOTE: A bare value here is standard SQL syntax, believe it or
            // not.  Taken together with multi-row table constructors, it leads
            // to very easy mistakes if you forget the parentheses on a
            // single-row constructor.  This is also the reason for the
            // LOOKAHEAD in RowConstructorList().  It would be so much more
            // reasonable to require parentheses.  Sigh.
            s = Span.of(value);
            valueList = new SqlNodeList(Collections.singletonList(value),value.getPos());
        }
    )
    {
        // REVIEW jvs: Should we discriminate between scalar
        // sub-queries inside of ROW and row sub-queries?  The standard does,
        // but the distinction seems to be purely syntactic.
        return (SqlCall) OperatorRegistry.get( OperatorName.ROW ).createCall(s.end(valueList),valueList.toArray());
    }
}

/**
 * Parses the optional WHERE clause for SELECT, DELETE, and UPDATE.
 */
SqlNode WhereOpt() :
{
    SqlNode condition;
}
{
    <WHERE> condition = Expression(ExprContext.ACCEPT_SUB_QUERY)
    {
        return condition;
    }
    |
    {
        return null;
    }
}

/**
 * Parses the optional GROUP BY clause for SELECT.
 */
SqlNodeList GroupByOpt() :
{
    List<SqlNode> list = new ArrayList<SqlNode>();
    final Span s;
}
{
    <GROUP> { s = span(); }
    <BY> list = GroupingElementList() {
        return new SqlNodeList(list, s.addAll(list).pos());
    }
|
    {
        return null;
    }
}

List<SqlNode> GroupingElementList() :
{
    List<SqlNode> list = new ArrayList<SqlNode>();
    SqlNode e;
}
{
    e = GroupingElement() { list.add(e); }
    (
        <COMMA>
        e = GroupingElement() { list.add(e); }
    )*
    { return list; }
}

SqlNode GroupingElement() :
{
    List<SqlNode> list;
    final SqlNodeList nodes;
    final SqlNode e;
    final Span s;
}
{
    <GROUPING> { s = span(); }
    <SETS> <LPAREN> list = GroupingElementList() <RPAREN> {
        return (SqlCall) OperatorRegistry.get( OperatorName.GROUPING_SETS ).createCall(s.end(this), list);
    }
|   <ROLLUP> { s = span(); }
    <LPAREN> nodes = ExpressionCommaList(s, ExprContext.ACCEPT_SUB_QUERY)
    <RPAREN> {
        return (SqlCall) OperatorRegistry.get( OperatorName.ROLLUP ).createCall(s.end(this), nodes.getList());
    }
|   <CUBE> { s = span(); }
    <LPAREN> nodes = ExpressionCommaList(s, ExprContext.ACCEPT_SUB_QUERY)
    <RPAREN> {
        return (SqlCall) OperatorRegistry.get( OperatorName.CUBE ).createCall(s.end(this), nodes.getList());
    }
|   LOOKAHEAD(3)
    <LPAREN> <RPAREN> {
        return new SqlNodeList(getPos());
    }
|   e = Expression(ExprContext.ACCEPT_SUB_QUERY) {
        return e;
    }
}

/**
 * Parses a list of expressions separated by commas.
 */
SqlNodeList ExpressionCommaList( Span s, ExprContext exprContext) :
{
    List<SqlNode> list;
    SqlNode e;
}
{
    e = Expression(exprContext)
    {
        list = startList(e);
    }
    (
        // NOTE jvs 6-Feb-2004:  See comments at top of file for why
        // hint is necessary here.
        LOOKAHEAD(2)
        <COMMA> e = Expression(ExprContext.ACCEPT_SUB_QUERY)
        {
            list.add(e);
        }
    )*
    {
        return new SqlNodeList(list, s.addAll(list).pos());
    }
}

/**
 * Parses the optional HAVING clause for SELECT.
 */
SqlNode HavingOpt() :
{
    SqlNode e;
}
{
    <HAVING> e = Expression(ExprContext.ACCEPT_SUB_QUERY) { return e; }
|
    { return null; }
}

/**
 * Parses the optional WINDOW clause for SELECT
 */
SqlNodeList WindowOpt() :
{
    SqlIdentifier id;
    SqlWindow e;
    List<SqlNode> list;
    final Span s;
}
{
    <WINDOW> { s = span(); }
    id = SimpleIdentifier() <AS> e = WindowSpecification() {
        e.setDeclName(id);
        list = startList(e);
    }
    (
        // NOTE jhyde 22-Oct-2004:  See comments at top of file for why
        // hint is necessary here.
        LOOKAHEAD(2)
        <COMMA> id = SimpleIdentifier() <AS> e = WindowSpecification() {
            e.setDeclName(id);
            list.add(e);
        }
    )*
    {
        return new SqlNodeList(list, s.addAll(list).pos());
    }
|
    {
        return null;
    }
}

/**
 * Parses a window specification.
 */
SqlWindow WindowSpecification() :
{
    SqlIdentifier id;
    List list;
    SqlNodeList partitionList;
    SqlNodeList orderList;
    SqlLiteral isRows = SqlLiteral.createBoolean(false, ParserPos.ZERO);
    SqlNode lowerBound = null, upperBound = null;
    ParserPos startPos;
    final Span s, s1, s2;
    SqlLiteral allowPartial = null;
}
{
    <LPAREN> { s = span(); }
    (
        id = SimpleIdentifier()
    |
        { id = null; }
    )
    (
        <PARTITION> { s1 = span(); }
        <BY>
        partitionList = ExpressionCommaList(s1, ExprContext.ACCEPT_NON_QUERY)
    |
        { partitionList = SqlNodeList.EMPTY; }
    )
    (
        orderList = OrderBy(true)
    |
        { orderList = SqlNodeList.EMPTY; }
    )
    [
        (
            <ROWS> { isRows = SqlLiteral.createBoolean(true, getPos()); }
        |
            <RANGE> { isRows = SqlLiteral.createBoolean(false, getPos()); }
        )
        (
            <BETWEEN> lowerBound = WindowRange()
            <AND> upperBound = WindowRange()
        |
            lowerBound = WindowRange()
        )
    ]
    [
        <ALLOW> { s2 = span(); } <PARTIAL> {
            allowPartial = SqlLiteral.createBoolean(true, s2.end(this));
        }
    |
        <DISALLOW> { s2 = span(); } <PARTIAL> {
            allowPartial = SqlLiteral.createBoolean(false, s2.end(this));
        }
    ]
    <RPAREN>
    {
        return SqlWindow.create(null, id, partitionList, orderList, isRows, lowerBound, upperBound, allowPartial, s.end(this));
    }
}

SqlNode WindowRange() :
{
    final SqlNode e;
    final Span s;
}
{
    <CURRENT> { s = span(); } <ROW> {
        return (SqlNode) SqlWindow.createCurrentRow(s.end(this));
    }
|
    <UNBOUNDED> { s = span(); }
    (
        <PRECEDING> {
            return (SqlNode) SqlWindow.createUnboundedPreceding(s.end(this));
        }
    |
        <FOLLOWING> {
            return (SqlNode) SqlWindow.createUnboundedFollowing(s.end(this));
        }
    )
|
    e = Expression(ExprContext.ACCEPT_NON_QUERY)
    (
        <PRECEDING> {
            return (SqlNode) SqlWindow.createPreceding(e, getPos());
        }
    |
        <FOLLOWING> {
            return (SqlNode) SqlWindow.createFollowing(e, getPos());
        }
    )
}

/**
 * Parses an ORDER BY clause.
 */
SqlNodeList OrderBy(boolean accept) :
{
    List<SqlNode> list;
    SqlNode e;
    final Span s;
}
{
    <ORDER> {
        s = span();
        if (!accept) {
            // Someone told us ORDER BY wasn't allowed here.  So why
            // did they bother calling us?  To get the correct
            // parser position for error reporting.
            throw CoreUtil.newContextException(s.pos(), RESOURCE.illegalOrderBy());
        }
    }
    <BY> e = OrderItem() {
        list = startList(e);
    }
    (
        // NOTE jvs 6-Feb-2004:  See comments at top of file for why
        // hint is necessary here.
        LOOKAHEAD(2) <COMMA> e = OrderItem() { list.add(e); }
    )*
    {
        return new SqlNodeList(list, s.addAll(list).pos());
    }
}

/**
 * Parses one list item in an ORDER BY clause.
 */
SqlNode OrderItem() :
{
    SqlNode e;
}
{
    e = Expression(ExprContext.ACCEPT_SUB_QUERY)
    (
        <ASC>
    |   <DESC> {
            e = (SqlCall) OperatorRegistry.get( OperatorName.DESC ).createCall(getPos(), e);
        }
    )?
    (
        <NULLS> <FIRST> {
            e = (SqlCall) OperatorRegistry.get( OperatorName.NULLS_FIRST ).createCall(getPos(), e);
        }
    |
        <NULLS> <LAST> {
            e = (SqlCall) OperatorRegistry.get( OperatorName.NULLS_LAST ).createCall(getPos(), e);
        }
    )?
    {
        return e;
    }
}

/**
 * Parses a MATCH_RECOGNIZE clause following a table expression.
 */
SqlMatchRecognize MatchRecognizeOpt(SqlNode tableRef) :
{
    final Span s, s0, s1, s2;
    SqlNodeList measureList = SqlNodeList.EMPTY;
    SqlNodeList partitionList = SqlNodeList.EMPTY;
    SqlNodeList orderList = SqlNodeList.EMPTY;
    SqlNode pattern;
    SqlLiteral interval;
    SqlNodeList patternDefList;
    final SqlNode after;
    ParserPos pos;
    final SqlNode var;
    final SqlLiteral rowsPerMatch;
    SqlNodeList subsetList = SqlNodeList.EMPTY;
    SqlLiteral isStrictStarts = SqlLiteral.createBoolean(false, getPos());
    SqlLiteral isStrictEnds = SqlLiteral.createBoolean(false, getPos());
}
{
    <MATCH_RECOGNIZE> { s = span(); } <LPAREN>
    [
        <PARTITION> { s2 = span(); } <BY>
        partitionList = ExpressionCommaList(s2, ExprContext.ACCEPT_NON_QUERY)
    ]
    [
        orderList = OrderBy(true)
    ]
    [
        <MEASURES>
        measureList = MeasureColumnCommaList(span())
    ]
    (
        <ONE> { s0 = span(); } <ROW> <PER> <MATCH> {
            rowsPerMatch = SqlLiteral.createSymbol(SqlMatchRecognize.RowsPerMatchOption.ONE_ROW, s0.end(this));
        }
    |
        <ALL> { s0 = span(); } <ROWS> <PER> <MATCH> {
            rowsPerMatch = SqlLiteral.createSymbol(SqlMatchRecognize.RowsPerMatchOption.ALL_ROWS, s0.end(this));
        }
    |
        {
            rowsPerMatch = null;
        }
    )
    (
        <AFTER> { s1 = span(); } <MATCH> <SKIP_>
        (
            <TO>
            (
                LOOKAHEAD(2)
                <NEXT> <ROW> {
                    after = SqlMatchRecognize.AfterOption.SKIP_TO_NEXT_ROW.symbol(
                        s1.end(this));
                }
            |
                <FIRST> var = SimpleIdentifier() {
                    after = (SqlCall) SqlMatchRecognize.SKIP_TO_FIRST.createCall(
                        s1.end(var), var);
                }
            |
                [ <LAST> ] var = SimpleIdentifier() {
                    after = (SqlCall) SqlMatchRecognize.SKIP_TO_LAST.createCall(
                        s1.end(var), var);
                }
            )
        |
            <PAST> <LAST> <ROW> {
                 after = SqlLiteral.createSymbol(SqlMatchRecognize.AfterOption.SKIP_PAST_LAST_ROW, s1.end(this));
            }
        )
    |
        { after = null; }
    )
    <PATTERN>
    <LPAREN>
    (
        <CARET> { isStrictStarts = SqlLiteral.createBoolean(true, getPos()); }
    |
        { isStrictStarts = SqlLiteral.createBoolean(false, getPos()); }
    )
    pattern = PatternExpression()
    (
        <DOLLAR> { isStrictEnds = SqlLiteral.createBoolean(true, getPos()); }
    |
        { isStrictEnds = SqlLiteral.createBoolean(false, getPos()); }
    )
    <RPAREN>
    (
        <WITHIN> interval = IntervalLiteral()
    |
        { interval = null; }
    )
    [
        <SUBSET>
        subsetList = SubsetDefinitionCommaList(span())
    ]
    <DEFINE>
    patternDefList = PatternDefinitionCommaList(span())
    <RPAREN> {
        return new SqlMatchRecognize(s.end(this), tableRef,
            pattern, isStrictStarts, isStrictEnds, patternDefList, measureList,
            after, subsetList, rowsPerMatch, partitionList, orderList, interval);
    }
}

SqlNodeList MeasureColumnCommaList(Span s) :
{
    SqlNode e;
    final List<SqlNode> eList = new ArrayList<SqlNode>();
}
{
    e = MeasureColumn() {
        eList.add(e);
    }
    (
        <COMMA>
        e = MeasureColumn() {
            eList.add(e);
        }
    )*
    {
        return new SqlNodeList(eList, s.addAll(eList).pos());
    }
}

SqlNode MeasureColumn() :
{
    SqlNode e;
    SqlIdentifier alias;
}
{
    e = Expression(ExprContext.ACCEPT_NON_QUERY)
    <AS>
    alias = SimpleIdentifier() {
        return (SqlCall) OperatorRegistry.get( OperatorName.AS ).createCall(Span.of(e).end(this), e, alias);
    }
}

SqlNode PatternExpression() :
{
    SqlNode left;
    SqlNode right;
}
{
    left = PatternTerm()
    (
        <VERTICAL_BAR>
        right = PatternTerm() {
            left = (SqlCall) OperatorRegistry.get( OperatorName.PATTERN_ALTER ).createCall(Span.of(left).end(right), left, right);
        }
    )*
    {
        return left;
    }
}

SqlNode PatternTerm() :
{
    SqlNode left;
    SqlNode right;
}
{
    left = PatternFactor()
    (
        right = PatternFactor() {
            left = (SqlCall) OperatorRegistry.get( OperatorName.PATTERN_CONCAT ).createCall(
                Span.of(left).end(right), left, right);
        }
    )*
    {
        return left;
    }
}

SqlNode PatternFactor() :
{
    SqlNode e;
    SqlNode extra;
    SqlLiteral startNum = null;
    SqlLiteral endNum = null;
    SqlLiteral reluctant = SqlLiteral.createBoolean(false, ParserPos.ZERO);
}
{
    e = PatternPrimary()
    [
        (
            <STAR> {
                startNum = SqlLiteral.createExactNumeric("0", ParserPos.ZERO);
                endNum = SqlLiteral.createExactNumeric("-1", ParserPos.ZERO);
            }
        |
            <PLUS> {
                startNum = SqlLiteral.createExactNumeric("1", ParserPos.ZERO);
                endNum = SqlLiteral.createExactNumeric("-1", ParserPos.ZERO);
            }
        |
            <HOOK> {
                startNum = SqlLiteral.createExactNumeric("0", ParserPos.ZERO);
                endNum = SqlLiteral.createExactNumeric("1", ParserPos.ZERO);
            }
        |
            <LBRACE>
            (
                startNum = UnsignedNumericLiteral() { endNum = startNum; }
                [
                    <COMMA> {
                        endNum = SqlLiteral.createExactNumeric("-1", ParserPos.ZERO);
                    }
                    [
                        endNum = UnsignedNumericLiteral()
                    ]
                ]
                <RBRACE>
            |
                {
                    startNum = SqlLiteral.createExactNumeric("-1", ParserPos.ZERO);
                }
                <COMMA>
                endNum = UnsignedNumericLiteral()
                <RBRACE>
            |
                <MINUS> extra = PatternExpression() <MINUS> <RBRACE> {
                    extra = (SqlCall) OperatorRegistry.get( OperatorName.PATTERN_EXCLUDE ).createCall(
                        Span.of(extra).end(this), extra);
                    e = (SqlCall) OperatorRegistry.get( OperatorName.PATTERN_CONCAT ).createCall(
                        Span.of(e).end(this), e, extra);
                    return e;
                }
            )
        )
        [
            <HOOK>
            {
                if (startNum.intValue(true) != endNum.intValue(true)) {
                    reluctant = SqlLiteral.createBoolean(true, ParserPos.ZERO);
                }
            }
        ]
    ]
    {
        if (startNum == null) {
            return e;
        } else {
            return (SqlCall) OperatorRegistry.get( OperatorName.PATTERN_QUANTIFIER ).createCall(
                span().end(e), e, startNum, endNum, reluctant);
        }
    }
}

SqlNode PatternPrimary() :
{
    final Span s;
    SqlNode e;
    List<SqlNode> eList;
}
{
    (
        e = SimpleIdentifier()
    |
        <LPAREN> e = PatternExpression() <RPAREN>
    |
        <LBRACE> { s = span(); }
        <MINUS> e = PatternExpression()
        <MINUS> <RBRACE> {
            e = (SqlCall) OperatorRegistry.get( OperatorName.PATTERN_EXCLUDE ).createCall(s.end(this), e);
        }
    |
        (
            <PERMUTE> { s = span(); }
            <LPAREN>
            e = PatternExpression() {
                eList = new ArrayList<SqlNode>();
                eList.add(e);
            }
            (
                <COMMA>
                e = PatternExpression()
                {
                    eList.add(e);
                }
            )*
            <RPAREN> {
                e = (SqlCall) OperatorRegistry.get( OperatorName.PATTERN_PERMUTE ).createCall(
                    s.end(this), eList);
            }
        )
    )
    {
        return e;
    }
}

SqlNodeList SubsetDefinitionCommaList(Span s) :
{
    SqlNode e;
    final List<SqlNode> eList = new ArrayList<SqlNode>();
}
{
    e = SubsetDefinition() {
        eList.add(e);
    }
    (
        <COMMA>
        e = SubsetDefinition() {
            eList.add(e);
        }
    )*
    {
        return new SqlNodeList(eList, s.addAll(eList).pos());
    }
}

SqlNode SubsetDefinition() :
{
    final SqlNode var;
    final SqlNodeList varList;
}
{
    var = SimpleIdentifier()
    <EQ>
    <LPAREN>
    varList = ExpressionCommaList(span(), ExprContext.ACCEPT_NON_QUERY)
    <RPAREN> {
        return (SqlCall) OperatorRegistry.get( OperatorName.EQUALS ).createCall(span().end(var), var,
            varList);
    }
}

SqlNodeList PatternDefinitionCommaList(Span s) :
{
    SqlNode e;
    final List<SqlNode> eList = new ArrayList<SqlNode>();
}
{
    e = PatternDefinition() {
        eList.add(e);
    }
    (
        <COMMA>
        e = PatternDefinition() {
            eList.add(e);
        }
    )*
    {
        return new SqlNodeList(eList, s.addAll(eList).pos());
    }
}

SqlNode PatternDefinition() :
{
    final SqlNode var;
    final SqlNode e;
}
{
    var = SimpleIdentifier()
    <AS>
    e = Expression(ExprContext.ACCEPT_SUB_QUERY) {
        return (SqlCall) OperatorRegistry.get( OperatorName.AS ).createCall(Span.of(var, e).pos(), e, var);
    }
}

// ----------------------------------------------------------------------------
// Expressions

/**
 * Parses a SQL expression (such as might occur in a WHERE clause) followed by
 * the end-of-file symbol.
 */
SqlNode SqlExpressionEof() :
{
    SqlNode e;
}
{
    e = Expression(ExprContext.ACCEPT_SUB_QUERY) (<EOF>)
    {
        return e;
    }
}

/**
 * Parses either a row expression or a query expression without ORDER BY.
 */
SqlNode QueryOrExpr(ExprContext exprContext) :
{
    SqlNodeList withList = null;
    SqlNode e;
    SqlOperator op;
    ParserPos pos;
    ParserPos withPos;
    List<Object> list;
}
{
    [
        withList = WithList()
    ]
    e = LeafQueryOrExpr(exprContext) {
        list = startList(e);
    }
    (
        {
            if (!e.isA(Kind.QUERY)) {
                // whoops, expression we just parsed wasn't a query,
                // but we're about to see something like UNION, so
                // force an exception retroactively
                checkNonQueryExpression(ExprContext.ACCEPT_QUERY);
            }
        }
        op = BinaryQueryOperator() {
            // ensure a query is legal in this context
            pos = getPos();
            checkQueryExpression(exprContext);

        }
        e = LeafQueryOrExpr(ExprContext.ACCEPT_QUERY) {
            list.add(new SqlParserUtil.ToTreeListItem(op, pos));
            list.add(e);
        }
    )*
    {
        e = SqlParserUtil.toTree(list);
        if (withList != null) {
            e = new SqlWith(withList.getPos(), withList, e);
        }
        return e;
    }
}

SqlNodeList WithList() :
{
    SqlWithItem withItem;
    ParserPos pos;
    SqlNodeList list;
}
{
    <WITH> { list = new SqlNodeList(getPos()); }
    withItem = WithItem() {list.add(withItem);}
    (
        <COMMA> withItem = WithItem() {list.add(withItem);}
    )*
    { return list; }
}

SqlWithItem WithItem() :
{
    SqlIdentifier id;
    SqlNodeList columnList = null;
    SqlNode definition;
}
{
    id = SimpleIdentifier()
    [
        LOOKAHEAD(2)
        columnList = ParenthesizedSimpleIdentifierList()
    ]
    <AS>
    definition = ParenthesizedExpression(ExprContext.ACCEPT_QUERY)
    {
        return new SqlWithItem(id.getPos(), id, columnList,
            definition);
    }
}

/**
 * Parses either a row expression, a leaf query expression, or
 * a parenthesized expression of any kind.
 */
SqlNode LeafQueryOrExpr(ExprContext exprContext) :
{
    SqlNode e;
}
{
    e = Expression(exprContext) { return e; }
|
    e = LeafQuery(exprContext) { return e; }
}

/**
 * Parses a row expression or a parenthesized expression of any kind.
 */
SqlNode Expression(ExprContext exprContext) :
{
    List<Object> list;
    SqlNode e;
}
{
    list = Expression2(exprContext)
    {
        e = SqlParserUtil.toTree(list);
        return e;
    }
}

// TODO jvs 15-Nov-2003:  ANY/ALL

void Expression2b(ExprContext exprContext, List<Object> list) :
{
    SqlNode e;
    SqlOperator op;
    String p;
}
{
    (
        op = PrefixRowOperator() {
            checkNonQueryExpression(exprContext);
            list.add(new SqlParserUtil.ToTreeListItem(op, getPos()));
        }
    )*
    e = Expression3(exprContext) {
        list.add(e);
    }
    (
        <DOT>
        p = Identifier() {
            list.add(
                new SqlParserUtil.ToTreeListItem(
                    OperatorRegistry.get( OperatorName.DOT, SqlOperator.class ), getPos()));
            list.add(new SqlIdentifier(p, getPos()));
        }
    )*
}

/**
 * Parses a binary row expression, or a parenthesized expression of any
 * kind.
 *
 * <p>The result is as a flat list of operators and operands. The top-level
 * call to get an expression should call {@link #Expression}, but lower-level
 * calls should call this, to give the parser the opportunity to associate
 * operator calls.
 *
 * <p>For example 'a = b like c = d' should come out '((a = b) like c) = d'
 * because LIKE and '=' have the same precedence, but tends to come out as '(a
 * = b) like (c = d)' because (a = b) and (c = d) are parsed as separate
 * expressions.
 */
List<Object> Expression2(ExprContext exprContext) :
{
    final List<Object> list = new ArrayList();
    List<Object> list2;
    final List<Object> list3 = new ArrayList();
    SqlNodeList nodeList;
    SqlNode e;
    List<Object> arrayItemList;
    SqlOperator op;
    String p;
    final Span s = span();
}
{
    Expression2b(exprContext, list)
    (
        (
            LOOKAHEAD(2)
            (
                // Special case for "IN", because RHS of "IN" is the only place
                // that an expression-list is allowed ("exp IN (exp1, exp2)").
                LOOKAHEAD(2) {
                    checkNonQueryExpression(exprContext);
                }
                (
                    <NOT> <IN> { op = OperatorRegistry.get( OperatorName.NOT_IN, SqlOperator.class ); }
                |
                    <IN> { op = OperatorRegistry.get( OperatorName.IN, SqlOperator.class ); }
                |
                    { final Kind k; }
                    k = comp()
                    (
                        <SOME> { op = SqlStdOperatorTable.some(k); }
                    |
                        <ANY> { op = SqlStdOperatorTable.some(k); }
                    |
                        <ALL> { op = SqlStdOperatorTable.all(k); }
                    )
                )
                { s.clear().add(this); }
                nodeList = ParenthesizedQueryOrCommaList(ExprContext.ACCEPT_NONCURSOR)
                {
                    list.add(new SqlParserUtil.ToTreeListItem(op, s.pos()));
                    s.add(nodeList);
                    // special case for stuff like IN (s1 UNION s2)
                    if (nodeList.size() == 1) {
                        SqlNode item = nodeList.getSqlList().get(0);
                        if (item.isA(Kind.QUERY)) {
                            list.add(item);
                        } else {
                            list.add(nodeList);
                        }
                    } else {
                        list.add(nodeList);
                    }
                }
            |
                LOOKAHEAD(2) {
                    checkNonQueryExpression(exprContext);
                }
                (
                    <NOT> <BETWEEN> {
                        op = OperatorRegistry.get( OperatorName.NOT_BETWEEN, SqlOperator.class );
                        s.clear().add(this);
                    }
                    [
                        <SYMMETRIC> { op = OperatorRegistry.get( OperatorName.SYMMETRIC_NOT_BETWEEN, SqlOperator.class ); }
                    |
                        <ASYMMETRIC>
                    ]
                |
                    <BETWEEN>
                    {
                        op = OperatorRegistry.get( OperatorName.BETWEEN, SqlOperator.class );
                        s.clear().add(this);
                    }
                    [
                        <SYMMETRIC> { op = OperatorRegistry.get( OperatorName.SYMMETRIC_BETWEEN, SqlOperator.class ); }
                    |
                        <ASYMMETRIC>
                    ]
                )
                Expression2b(ExprContext.ACCEPT_SUB_QUERY, list3) {
                    list.add(new SqlParserUtil.ToTreeListItem(op, s.pos()));
                    list.addAll(list3);
                    list3.clear();
                }
            |
                {
                    checkNonQueryExpression(exprContext);
                    s.clear().add(this);
                }
                (
                    <NOT>
                    (
                        <LIKE> { op = OperatorRegistry.get( OperatorName.NOT_LIKE, SqlOperator.class ); }
                    |
                        <SIMILAR> <TO> { op = OperatorRegistry.get( OperatorName.NOT_SIMILAR_TO, SqlOperator.class ); }
                    )
                |
                    <LIKE> { op = OperatorRegistry.get( OperatorName.LIKE, SqlOperator.class ); }
                |
                    <SIMILAR> <TO> { op = OperatorRegistry.get( OperatorName.SIMILAR_TO, SqlOperator.class ); }
                )
                list2 = Expression2(ExprContext.ACCEPT_SUB_QUERY) {
                    list.add(new SqlParserUtil.ToTreeListItem(op, s.pos()));
                    list.addAll(list2);
                }
                [
                    LOOKAHEAD(2)
                    <ESCAPE> e = Expression3(ExprContext.ACCEPT_SUB_QUERY) {
                        s.clear().add(this);
                        list.add(
                            new SqlParserUtil.ToTreeListItem(
                                OperatorRegistry.get( OperatorName.ESCAPE, SqlOperator.class ), s.pos()));
                        list.add(e);
                    }
                ]
            |
                LOOKAHEAD(3) op = BinaryRowOperator() {
                    checkNonQueryExpression(exprContext);
                    list.add(new SqlParserUtil.ToTreeListItem(op, getPos()));
                }
                Expression2b(ExprContext.ACCEPT_SUB_QUERY, list)
            |
                arrayItemList = ArrayItem(s)
                { list.addAll(arrayItemList); }
                (
                    <DOT>
                    p = Identifier() {
                        list.add(
                            new SqlParserUtil.ToTreeListItem(
                                OperatorRegistry.get( OperatorName.DOT, SqlOperator.class ), getPos()));
                        list.add(new SqlIdentifier(p, getPos()));
                    }
                )*
            |
                {
                    checkNonQueryExpression(exprContext);
                }
                op = PostfixRowOperator() {
                    list.add(new SqlParserUtil.ToTreeListItem(op, getPos()));
                }
            )
        )+
        {
            return list;
        }
    |
        {
            return list;
        }
    )
}

/** Parses a comparison operator inside a SOME / ALL predicate. */
Kind comp() :
{
}
{
    <LT> { return Kind.LESS_THAN; }
|
    <LE> { return Kind.LESS_THAN_OR_EQUAL; }
|
    <GT> { return Kind.GREATER_THAN; }
|
    <GE> { return Kind.GREATER_THAN_OR_EQUAL; }
|
    <EQ> { return Kind.EQUALS; }
|
    <NE> { return Kind.NOT_EQUALS; }
|
    <NE2> {
        if (!this.conformance.isBangEqualAllowed()) {
            throw new ParseException(RESOURCE.bangEqualNotAllowed().str());
        }
        return Kind.NOT_EQUALS;
    }
}

/**
 * Parses a unary row expression, or a parenthesized expression of any
 * kind.
 */
SqlNode Expression3(ExprContext exprContext) :
{
    final SqlNode e;
    final SqlNodeList list;
    final SqlNodeList list1;
    final SqlNodeList list2;
    final SqlOperator op;
    final Span s;
    Span rowSpan = null;
}
{
    LOOKAHEAD(2)
    e = AtomicRowExpression()
    {
        checkNonQueryExpression(exprContext);
        return e;
    }
|
    e = CursorExpression(exprContext) { return e; }
|
    LOOKAHEAD(3)
    <ROW> {
        s = span();
    }
    list = ParenthesizedSimpleIdentifierList() {
        if (exprContext != ExprContext.ACCEPT_ALL
            && exprContext != ExprContext.ACCEPT_CURSOR
            && !this.conformance.allowExplicitRowValueConstructor())
        {
            throw CoreUtil.newContextException(s.end(list),
                RESOURCE.illegalRowExpression());
        }
        return (SqlCall) OperatorRegistry.get( OperatorName.ROW, SqlOperator.class ).createCall(list);
    }
|
    [
        <ROW> { rowSpan = span(); }
    ]
    list1 = ParenthesizedQueryOrCommaList(exprContext) {
        if (rowSpan != null) {
            // interpret as row constructor
            return (SqlCall) OperatorRegistry.get( OperatorName.ROW, SqlOperator.class ).createCall(rowSpan.end(list1),
                list1.toArray());
        }
    }
    [
        LOOKAHEAD(2)
        /* TODO:
        (
            op = periodOperator()
            list2 = ParenthesizedQueryOrCommaList(exprContext)
            {
                if (list1.size() != 2 || list2.size() != 2) {
                    throw CoreUtil.newContextException(
                        list1.getPos().plus(
                            list2.getPos()),
                        RESOURCE.illegalOverlaps());
                }
                for (SqlNode node : list2) {
                    list1.add(node);
                }
                return op.createCall(
                    list1.getPos().plus(list2.getPos()),
                    list1.toArray());
            }
        )
    |
        */
        (
            e = IntervalQualifier()
            {
                if ((list1.size() == 1)
                    && list1.get(0) instanceof SqlCall)
                {
                    final SqlCall call = (SqlCall) list1.get(0);
                    if (call.getKind() == Kind.MINUS
                            && call.operandCount() == 2) {
                        List<SqlNode> list3 = startList(call.operand(0));
                        list3.add(call.operand(1));
                        list3.add(e);
                        return (SqlCall) OperatorRegistry.get( OperatorName.MINUS_DATE ).createCall(
                            Span.of(list1).end(this), list3);
                     }
                }
                throw CoreUtil.newContextException(span().end(list1),
                    RESOURCE.illegalMinusDate());
            }
        )
    ]
    {
        if (list1.size() == 1) {
            // interpret as single value or query
            return list1.getSqlList().get(0);
        } else {
            // interpret as row constructor
            return (SqlCall) OperatorRegistry.get( OperatorName.ROW ).createCall(span().end(list1),
                list1.toArray());
        }
    }
}

SqlOperator periodOperator() :
{
}
{
     <OVERLAPS> { return OperatorRegistry.get( OperatorName.OVERLAPS, SqlOperator.class ); }
|
     <IMMEDIATELY> <PRECEDES> { return OperatorRegistry.get( OperatorName.IMMEDIATELY_PRECEDES, SqlOperator.class ); }
|
     <PRECEDES> { return OperatorRegistry.get( OperatorName.PRECEDES, SqlOperator.class ); }
|
     <IMMEDIATELY> <SUCCEEDS> { return OperatorRegistry.get( OperatorName.IMMEDIATELY_SUCCEEDS, SqlOperator.class ); }
|
     <SUCCEEDS> { return OperatorRegistry.get( OperatorName.SUCCEEDS, SqlOperator.class ); }
|
     <EQUALS> { return OperatorRegistry.get( OperatorName.PERIOD_EQUALS, SqlOperator.class ); }
}

/**
 * Parses a COLLATE clause
 */
SqlCollation CollateClause() :
{
}
{
    <COLLATE> <COLLATION_ID>
    {
        return new SqlCollation(
            getToken(0).image, SqlCollation.Coercibility.EXPLICIT);
    }
}

/**
 * Numeric literal or parameter; used in LIMIT, OFFSET and FETCH clauses.
 */
SqlNode UnsignedNumericLiteralOrParam() :
{
    final SqlNode e;
}
{
    (
        e = UnsignedNumericLiteral()
    |
        e = DynamicParam()
    )
    { return e; }
}

/**
 * Parses an atomic row expression.
 */
SqlNode AtomicRowExpression() :
{
    final SqlNode e;
}
{
    (
        LOOKAHEAD(1)
        e = Literal()
    |
        e = DynamicParam()
    |
        e = BuiltinFunctionCall()
    |
        e = JdbcFunctionCall()
    |
        e = MultisetConstructor()
    |
        e = ArrayConstructor()
    |
        e = MapConstructor()
    |
        e = PeriodConstructor()
    |
        // NOTE jvs 18-Jan-2005:  use syntactic lookahead to discriminate
        // compound identifiers from function calls in which the function
        // name is a compound identifier
        LOOKAHEAD( [<SPECIFIC>] FunctionName() <LPAREN>)
        e = NamedFunctionCall()
    |
        e = ContextVariable()
    |
        e = CompoundIdentifier()
    |
        e = NewSpecification()
    |
        e = CaseExpression()
    |
        e = SequenceExpression()
    )
    { return e; }
}

SqlNode CaseExpression() :
{
    final Span whenSpan = Span.of();
    final Span thenSpan = Span.of();
    final Span s;
    SqlNode e;
    SqlNode caseIdentifier = null;
    SqlNode elseClause = null;
    List<SqlNode> whenList = new ArrayList<SqlNode>();
    List<SqlNode> thenList = new ArrayList<SqlNode>();
}
{
    <CASE> { s = span(); }
    [
        caseIdentifier = Expression(ExprContext.ACCEPT_SUB_QUERY)
    ]
    (
        <WHEN> { whenSpan.add(this); }
        e = ExpressionCommaList(s, ExprContext.ACCEPT_SUB_QUERY) {
            if (((SqlNodeList) e).size() == 1) {
                e = ((SqlNodeList) e).getSqlList().get(0);
            }
            whenList.add(e);
        }
        <THEN> { thenSpan.add(this); }
        e = Expression(ExprContext.ACCEPT_SUB_QUERY) {
            thenList.add(e);
        }
    )+
    [
        <ELSE> elseClause = Expression(ExprContext.ACCEPT_SUB_QUERY)
    ]
    <END> {
        return SqlCase.createSwitched(s.end(this), caseIdentifier,
            new SqlNodeList(whenList, whenSpan.addAll(whenList).pos()),
            new SqlNodeList(thenList, thenSpan.addAll(thenList).pos()),
            elseClause);
    }
}

SqlCall SequenceExpression() :
{
    final Span s;
    final SqlOperator f;
    final SqlNode sequenceRef;
}
{
    (
        <NEXT> { f = OperatorRegistry.get( OperatorName.NEXT_VALUE, SqlOperator.class ); s = span(); }
    |
        <CURRENT> { f = OperatorRegistry.get( OperatorName.CURRENT_VALUE, SqlOperator.class ); s = span(); }
    )
    <VALUE> <FOR> sequenceRef = CompoundIdentifier() {
        return (SqlCall) f.createCall(s.end(sequenceRef), sequenceRef);
    }
}


String Scope() :
{
}
{
    ( <SYSTEM> | <SESSION> ) { return token.image.toUpperCase(Locale.ROOT); }
}

/**
 * Parses "SET &lt;NAME&gt; = VALUE" or "RESET &lt;NAME&gt;", without a leading
 * "ALTER &lt;SCOPE&gt;".
 */
SqlSetOption SqlSetOption(Span s) :
{
    SqlIdentifier name;
    final SqlNode val;
    final String scope;
}
{
    scope = Scope()
    (
        <SET> {
            s.add(this);
        }
        name = CompoundIdentifier()
        <EQ>
        (
            val = Literal()
        |
            val = SimpleIdentifier()
        |
            <ON> {
                // OFF is handled by SimpleIdentifier, ON handled here.
                val = new SqlIdentifier(token.image.toUpperCase(Locale.ROOT), getPos());
            }
        )
        {
            return new SqlSetOption(s.end(val), scope, name, val);
        }
    |
        <RESET> {
            s.add(this);
        }
        (
            name = CompoundIdentifier()
        |
            <ALL> {
                name = new SqlIdentifier(token.image.toUpperCase(Locale.ROOT), getPos());
            }
        )
        {
            return new SqlSetOption(s.end(name), scope, name, null);
        }
    )
}

/**
 * Parses an expression for setting or resetting an option in SQL, such as QUOTED_IDENTIFIERS,
 * or explain plan level (physical/logical).
 */
SqlAlter SqlAlter() :
{
    final Span s;
    final SqlAlter alterNode;
}
{
    <ALTER> { s = span(); }
    (
        alterNode = SqlSetOption(s)
        |
        alterNode = SqlAlterNamespace(s)
        |
        alterNode = SqlAlterView(s)
        |
        alterNode = SqlAlterMaterializedView(s)
        |
        alterNode = SqlAlterTable(s)
        |
        alterNode = SqlAlterConfig(s)
        |
        alterNode = SqlAlterAdaptersAdd(s)
        |
        alterNode = SqlAlterAdaptersDrop(s)
        |
        alterNode = SqlAlterInterfacesAdd(s)
        |
        alterNode = SqlAlterInterfacesDrop(s)
    )
    {
        return alterNode;
    }
}

/**
 * Parses a CREATE statement.
 */
SqlCreate SqlCreate() :
{
    final Span s;
    boolean replace = false;
    final SqlCreate create;
}
{
    <CREATE> { s = span(); }
    [
        <OR> <REPLACE> {
            replace = true;
        }
    ]
    (
        create = SqlCreateNamespace(s, replace)
        |
        create = SqlCreateTable(s, replace)
        |
        create = SqlCreateType(s, replace)
        |
        create = SqlCreateView(s, replace)
        |
        create = SqlCreateMaterializedView(s, replace)
        |
        create = SqlCreateFunction(s, replace)
    )
    {
        return create;
    }
}


/**
 * Parses a DROP statement.
 */
SqlDrop SqlDrop() :
{
    final Span s;
    boolean replace = false;
    final SqlDrop drop;
}
{
    <DROP> { s = span(); }
    (
        drop = SqlDropNamespace(s, replace)
        |
        drop = SqlDropTable(s, replace)
        |
        drop = SqlDropType(s, replace)
        |
        drop = SqlDropView(s, replace)
        |
        drop = SqlDropMaterializedView(s, replace)
        |
        drop = SqlDropFunction(s, replace)
    )
    {
        return drop;
    }
}

/**
 * Parses a literal expression, allowing continued string literals.
 * Usually returns an SqlLiteral, but a continued string literal
 * is an SqlCall expression, which concatenates 2 or more string
 * literals; the validator reduces this.
 */
SqlNode Literal() :
{
    SqlNode e;
}
{
    (
        e = NumericLiteral()
    |
        e = StringLiteral()
    |
        e = SpecialLiteral()
    |
        e = DateTimeLiteral()
    |
        e = IntervalLiteral()
    )
    {
        return e;
    }


}

/** Parses a unsigned numeric literal */
SqlNumericLiteral UnsignedNumericLiteral() :
{
}
{
    <UNSIGNED_INTEGER_LITERAL> {
        return SqlLiteral.createExactNumeric(token.image, getPos());
    }
|
    <DECIMAL_NUMERIC_LITERAL> {
        return SqlLiteral.createExactNumeric(token.image, getPos());
    }
|
    <APPROX_NUMERIC_LITERAL> {
        return SqlLiteral.createApproxNumeric(token.image, getPos());
    }
}

/** Parses a numeric literal (can be signed) */
SqlLiteral NumericLiteral() :
{
    final SqlNumericLiteral num;
    final Span s;
}
{
    <PLUS> num = UnsignedNumericLiteral() {
        return num;
    }
|
    <MINUS> { s = span(); } num = UnsignedNumericLiteral() {
        return SqlLiteral.createNegative(num, s.end(this));
    }
|
    num = UnsignedNumericLiteral() {
        return num;
    }
}

/** Parse a special literal keyword */
SqlLiteral SpecialLiteral() :
{
}
{
    <TRUE> { return SqlLiteral.createBoolean(true, getPos()); }
|
    <FALSE> { return SqlLiteral.createBoolean(false, getPos()); }
|
    <UNKNOWN> { return SqlLiteral.createUnknown(getPos()); }
|
    <NULL> { return SqlLiteral.createNull(getPos()); }
}

/**
 * Parses a string literal. The literal may be continued onto several
 * lines.  For a simple literal, the result is an SqlLiteral.  For a continued
 * literal, the result is an SqlCall expression, which concatenates 2 or more
 * string literals; the validator reduces this.
 *
 * @see SqlLiteral#unchain(SqlNode)
 * @see SqlLiteral#stringValue(SqlNode)
 *
 * @return a literal expression
 */
SqlNode StringLiteral() :
{
    String p;
    int nfrags = 0;
    List<SqlLiteral> frags = null;
    char unicodeEscapeChar = 0;
}
{
    // A continued string literal consists of a head fragment and one or more
    // tail fragments. Since comments may occur between the fragments, and
    // comments are special tokens, each fragment is a token. But since spaces
    // or comments may not occur between the prefix and the first quote, the
    // head fragment, with any prefix, is one token.

    <BINARY_STRING_LITERAL>
    {
        try {
            p = CoreUtil.trim(token.image, "xX'");
            frags = startList(SqlLiteral.createBinaryString(p, getPos()));
            nfrags++;
        } catch (NumberFormatException ex) {
            throw CoreUtil.newContextException(getPos(),
                RESOURCE.illegalBinaryString(token.image));
        }
    }
    (
        <QUOTED_STRING>
        {
            try {
                p = CoreUtil.trim(token.image, "'"); // no embedded quotes
                frags.add(SqlLiteral.createBinaryString(p, getPos()));
                nfrags++;
            } catch (NumberFormatException ex) {
                throw CoreUtil.newContextException(getPos(),
                    RESOURCE.illegalBinaryString(token.image));
            }
        }
    )*
    {
        assert (nfrags > 0);
        if (nfrags == 1) {
            return frags.get(0); // just the head fragment
        } else {
            ParserPos pos2 = ParserPos.sum(frags);
            return (SqlCall) OperatorRegistry.get( OperatorName.LITERAL_CHAIN ).createCall(pos2, frags);
        }
    }
    |
    {
        String charSet = null;
    }
    (
        <PREFIXED_STRING_LITERAL>
        { charSet = CoreUtil.getCharacterSet(token.image); }
    |   <QUOTED_STRING>
    |   <UNICODE_STRING_LITERAL> {
            // TODO jvs 2-Feb-2009:  support the explicit specification of
            // a character set for Unicode string literals, per SQL:2003
            unicodeEscapeChar = BACKSLASH;
            charSet = "UTF16";
        }
    )
    {
        p = CoreUtil.parseString(token.image);
        SqlCharStringLiteral literal;
        try {
            literal = SqlLiteral.createCharString(p, charSet, getPos());
        } catch (java.nio.charset.UnsupportedCharsetException e) {
            throw CoreUtil.newContextException(getPos(),
                RESOURCE.unknownCharacterSet(charSet));
        }
        frags = startList(literal);
        nfrags++;
    }
    (
        <QUOTED_STRING>
        {
            p = CoreUtil.parseString(token.image);
            try {
                literal = SqlLiteral.createCharString(p, charSet, getPos());
            } catch (java.nio.charset.UnsupportedCharsetException e) {
                throw CoreUtil.newContextException(getPos(),
                    RESOURCE.unknownCharacterSet(charSet));
            }
            frags.add(literal);
            nfrags++;
        }
    )*
    [
        <UESCAPE> <QUOTED_STRING>
        {
            if (unicodeEscapeChar == 0) {
                throw CoreUtil.newContextException(getPos(),
                    RESOURCE.unicodeEscapeUnexpected());
            }
            String s = CoreUtil.parseString(token.image);
            unicodeEscapeChar = SqlParserUtil.checkUnicodeEscapeChar(s);
        }
    ]
    {
        assert nfrags > 0;
        if (nfrags == 1) {
            // just the head fragment
            SqlLiteral lit = (SqlLiteral) frags.get(0);
            return lit.unescapeUnicode(unicodeEscapeChar);
        } else {
            SqlNode[] rands = (SqlNode[]) frags.toArray(new SqlNode[nfrags]);
            for (int i = 0; i < rands.length; ++i) {
                rands[i] = ((SqlLiteral) rands[i]).unescapeUnicode(
                    unicodeEscapeChar);
            }
            ParserPos pos2 = ParserPos.sum(rands);
            return (SqlCall) OperatorRegistry.get( OperatorName.LITERAL_CHAIN ).createCall(pos2, rands);
        }
    }
}


/**
 * Parses a date/time literal.
 */
SqlLiteral DateTimeLiteral() :
{
    final String  p;
    final Span s;
}
{
    <LBRACE_D> <QUOTED_STRING> {
        p = token.image;
    }
    <RBRACE> {
        return SqlParserUtil.parseDateLiteral(p, getPos());
    }
|
    <LBRACE_T> <QUOTED_STRING> {
        p = token.image;
    }
    <RBRACE> {
        return SqlParserUtil.parseTimeLiteral(p, getPos());
    }
|
    <LBRACE_TS> { s = span(); } <QUOTED_STRING> {
        p = token.image;
    }
    <RBRACE> {
        return SqlParserUtil.parseTimestampLiteral(p, s.end(this));
    }
|
    <DATE> { s = span(); } <QUOTED_STRING> {
        return SqlParserUtil.parseDateLiteral(token.image, s.end(this));
    }
|
    <TIME> { s = span(); } <QUOTED_STRING> {
        return SqlParserUtil.parseTimeLiteral(token.image, s.end(this));
    }
|
    <TIMESTAMP> { s = span(); } <QUOTED_STRING> {
        return SqlParserUtil.parseTimestampLiteral(token.image, s.end(this));
    }
}

/** Parses a MULTISET constructor */
SqlNode MultisetConstructor() :
{
    List<SqlNode> args;
    SqlNode e;
    final Span s;
}
{
    <MULTISET> { s = span(); }
    (
        LOOKAHEAD(1)
        <LPAREN>
        // by sub query "MULTISET(SELECT * FROM T)"
        e = LeafQueryOrExpr(ExprContext.ACCEPT_QUERY)
        <RPAREN> {
            return (SqlCall) OperatorRegistry.get( OperatorName.MULTISET_QUERY ).createCall(
                s.end(this), e);
        }
    |
        // by enumeration "MULTISET[e0, e1, ..., eN]"
        <LBRACKET> // TODO: do trigraph as well ??( ??)
        e = Expression(ExprContext.ACCEPT_NON_QUERY) { args = startList(e); }
        (
            <COMMA> e = Expression(ExprContext.ACCEPT_NON_QUERY) { args.add(e); }
        )*
        <RBRACKET>
        {
            return (SqlCall) OperatorRegistry.get( OperatorName.MULTISET_VALUE ).createCall(
                s.end(this), args);
        }
    )
}

/** Parses an ARRAY constructor */
SqlNode ArrayConstructor() :
{
    SqlNodeList args;
    SqlNode e;
    final Span s;
}
{
    <ARRAY> { s = span(); }
    (
        LOOKAHEAD(1)
        <LPAREN>
        // by sub query "MULTISET(SELECT * FROM T)"
        e = LeafQueryOrExpr(ExprContext.ACCEPT_QUERY)
        <RPAREN>
        {
            return (SqlCall) OperatorRegistry.get( OperatorName.ARRAY_QUERY ).createCall(
                s.end(this), e);
        }
    |
        // by enumeration "ARRAY[e0, e1, ..., eN]"
        e = NestedArray(s)
        {
            return e;
        }
    )
}


/**
* Parse the content of an array, including the square brackets
* Supports nested arrays
*/
SqlNode NestedArray(Span s) :
{
    SqlNodeList args;
    List<SqlNode> list;
    SqlNode arr;
    int dimension = 1;
    int maxCardinality = 0;
    SqlArrayValueConstructor arrCtor;
}
{
    <LBRACKET>
    (
        arr = NestedArray(s)
        { if( arr instanceof SqlBasicCall && ((SqlBasicCall)arr).getOperator() instanceof SqlArrayValueConstructor ) {
            arrCtor = (SqlArrayValueConstructor)((SqlBasicCall)arr).getOperator();
            arrCtor.outermost = false;
            dimension = Math.max( dimension, arrCtor.dimension + 1 );
            maxCardinality = Math.max( arrCtor.maxCardinality, maxCardinality );
        }
        list = startList(arr); }
        (
            LOOKAHEAD(2)
            <COMMA>
            arr = NestedArray(s)
            { if( arr instanceof SqlBasicCall && ((SqlBasicCall)arr).getOperator() instanceof SqlArrayValueConstructor ) {
                arrCtor = (SqlArrayValueConstructor)((SqlBasicCall)arr).getOperator();
                arrCtor.outermost = false;
                dimension = Math.max( dimension, arrCtor.dimension + 1 );
                maxCardinality = Math.max( arrCtor.maxCardinality, maxCardinality );
            }
            list.add(arr); }
        )*
        {
            args = new SqlNodeList(list, s.addAll(list).pos());
        }
    |
        args = ExpressionCommaList(s, ExprContext.ACCEPT_NON_QUERY)
    |
        { args = SqlNodeList.EMPTY; }
    )
    <RBRACKET>
    {
        return (SqlCall) new SqlArrayValueConstructor( dimension, args.getList().size(), maxCardinality ).createCall( s.end(this), args.getList() );
    }
}

/**
* Parses an array accessor, e.g. myArray[1] (only the accessor [1])
* supports posgres-style slicing, e.g. myArray[1:2]
*/
List<Object> ArrayItem(Span s) :
{
    final List<Object> list = new ArrayList<Object>();
    SqlNode e1;
    SqlNode e2 = null;
    ParserPos pos;
}
{
    <LBRACKET>
    e1 = Expression(ExprContext.ACCEPT_SUB_QUERY)
    //allow postgres-syntax to get a specific array item: a[1:1]
    [
        <COLON>
        e2 = Expression(ExprContext.ACCEPT_SUB_QUERY)
    ]
    <RBRACKET> {
        list.add(
            new SqlParserUtil.ToTreeListItem(
                OperatorRegistry.get( OperatorName.ITEM, SqlOperator.class ), getPos()));
        list.add(e1);
        if(e2!=null){list.add(e2);}
        return list;
    }
}

/** Parses a MAP constructor */
SqlNode MapConstructor() :
{
    SqlNodeList args;
    SqlNode e;
    final Span s;
}
{
    <MAP> { s = span(); }
    (
        LOOKAHEAD(1)
        <LPAREN>
        // by sub query "MAP (SELECT empno, deptno FROM emp)"
        e = LeafQueryOrExpr(ExprContext.ACCEPT_QUERY)
        <RPAREN>
        {
            return (SqlCall) OperatorRegistry.get( OperatorName.MAP_QUERY ).createCall(
                s.end(this), e);
        }
    |
        // by enumeration "MAP[k0, v0, ..., kN, vN]"
        <LBRACKET> // TODO: do trigraph as well ??( ??)
        (
            args = ExpressionCommaList(s, ExprContext.ACCEPT_NON_QUERY)
        |
            { args = SqlNodeList.EMPTY; }
        )
        <RBRACKET>
        {
            return (SqlCall) OperatorRegistry.get( OperatorName.MAP_VALUE_CONSTRUCTOR ).createCall(
                s.end(this), args.getList());
        }
    )
}

/** Parses a PERIOD constructor */
SqlNode PeriodConstructor() :
{
    final SqlNode e0, e1;
    final Span s;
}
{
    <PERIOD> { s = span(); }
    <LPAREN>
    e0 = Expression(ExprContext.ACCEPT_SUB_QUERY)
    <COMMA>
    e1 = Expression(ExprContext.ACCEPT_SUB_QUERY)
    <RPAREN> {
        return (SqlCall) OperatorRegistry.get( OperatorName.ROW ).createCall(s.end(this), e0, e1);
    }
}

/**
 * Parses an interval literal.
 */
SqlLiteral IntervalLiteral() :
{
    final String p;
    final SqlIntervalQualifier intervalQualifier;
    int sign = 1;
    final Span s;
}
{
    <INTERVAL> { s = span(); }
    [
        <MINUS> { sign = -1; }
    |
        <PLUS> { sign = 1; }
    ]
    <QUOTED_STRING> { p = token.image; }
    intervalQualifier = IntervalQualifier() {
        return SqlParserUtil.parseIntervalLiteral(s.end(intervalQualifier),
            sign, p, intervalQualifier);
    }
}

SqlIntervalQualifier IntervalQualifier() :
{
    TimeUnit start;
    TimeUnit end = null;
    int startPrec = AlgDataType.PRECISION_NOT_SPECIFIED;
    int secondFracPrec = AlgDataType.PRECISION_NOT_SPECIFIED;
}
{
    (
        <YEAR> [ <LPAREN> startPrec = UnsignedIntLiteral() <RPAREN> ]
        [
            LOOKAHEAD(2) <TO> <MONTH>
            {
                end = TimeUnit.MONTH;
            }
        ]
        { start = TimeUnit.YEAR; }
    |
        <MONTH> [ <LPAREN> startPrec = UnsignedIntLiteral() <RPAREN> ]
        { start = TimeUnit.MONTH; }
    |
        <DAY> [ <LPAREN> startPrec = UnsignedIntLiteral() <RPAREN> ]
        [ LOOKAHEAD(2) <TO>
            (
                <HOUR> { end = TimeUnit.HOUR; }
            |
                <MINUTE> { end = TimeUnit.MINUTE; }
            |
                <SECOND> { end = TimeUnit.SECOND; }
                [ <LPAREN> secondFracPrec = UnsignedIntLiteral() <RPAREN> ]
            )
        ]
        { start = TimeUnit.DAY; }
    |
        <HOUR> [ <LPAREN> startPrec = UnsignedIntLiteral() <RPAREN> ]
        [ LOOKAHEAD(2) <TO>
            (
                <MINUTE> { end = TimeUnit.MINUTE; }
            |
                <SECOND> { end = TimeUnit.SECOND; }
                [ <LPAREN> secondFracPrec = UnsignedIntLiteral() <RPAREN> ]
            )
        ]
        { start = TimeUnit.HOUR; }
    |
        <MINUTE> [ <LPAREN> startPrec = UnsignedIntLiteral() <RPAREN> ]
        [ LOOKAHEAD(2) <TO>
            (
                <SECOND> { end = TimeUnit.SECOND; }
                [ <LPAREN> secondFracPrec = UnsignedIntLiteral() <RPAREN> ]
            )
        ]
        { start = TimeUnit.MINUTE; }
    |
        <SECOND>
        [   <LPAREN> startPrec = UnsignedIntLiteral()
            [ <COMMA> secondFracPrec = UnsignedIntLiteral() ]
            <RPAREN>
        ]
        { start = TimeUnit.SECOND; }
    )
    {
        return new SqlIntervalQualifier(start,
            startPrec,
            end,
            secondFracPrec,
            getPos());
    }
}

/**
 * Parses time unit for EXTRACT, CEIL and FLOOR functions.
 */
TimeUnit TimeUnit() :
{}
{
    <MICROSECOND> { return TimeUnit.MICROSECOND; }
|   <MILLISECOND> { return TimeUnit.MILLISECOND; }
|   <SECOND> { return TimeUnit.SECOND; }
|   <MINUTE> { return TimeUnit.MINUTE; }
|   <HOUR> { return TimeUnit.HOUR; }
|   <DAY> { return TimeUnit.DAY; }
|   <DOW> { return TimeUnit.DOW; }
|   <DOY> { return TimeUnit.DOY; }
|   <ISODOW> { return TimeUnit.ISODOW; }
|   <ISOYEAR> { return TimeUnit.ISOYEAR; }
|   <WEEK> { return TimeUnit.WEEK; }
|   <MONTH> { return TimeUnit.MONTH; }
|   <QUARTER> { return TimeUnit.QUARTER; }
|   <YEAR> { return TimeUnit.YEAR; }
|   <EPOCH> { return TimeUnit.EPOCH; }
|   <DECADE> { return TimeUnit.DECADE; }
|   <CENTURY> { return TimeUnit.CENTURY; }
|   <MILLENNIUM> { return TimeUnit.MILLENNIUM; }
}

TimeUnit TimestampInterval() :
{}
{
    <FRAC_SECOND> { return TimeUnit.MICROSECOND; }
|   <MICROSECOND> { return TimeUnit.MICROSECOND; }
|   <NANOSECOND> { return TimeUnit.NANOSECOND; }
|   <SQL_TSI_FRAC_SECOND> { return TimeUnit.NANOSECOND; }
|   <SQL_TSI_MICROSECOND> { return TimeUnit.MICROSECOND; }
|   <SECOND> { return TimeUnit.SECOND; }
|   <SQL_TSI_SECOND> { return TimeUnit.SECOND; }
|   <MINUTE> { return TimeUnit.MINUTE; }
|   <SQL_TSI_MINUTE> { return TimeUnit.MINUTE; }
|   <HOUR> { return TimeUnit.HOUR; }
|   <SQL_TSI_HOUR> { return TimeUnit.HOUR; }
|   <DAY> { return TimeUnit.DAY; }
|   <SQL_TSI_DAY> { return TimeUnit.DAY; }
|   <WEEK> { return TimeUnit.WEEK; }
|   <SQL_TSI_WEEK> { return TimeUnit.WEEK; }
|   <MONTH> { return TimeUnit.MONTH; }
|   <SQL_TSI_MONTH> { return TimeUnit.MONTH; }
|   <QUARTER> { return TimeUnit.QUARTER; }
|   <SQL_TSI_QUARTER> { return TimeUnit.QUARTER; }
|   <YEAR> { return TimeUnit.YEAR; }
|   <SQL_TSI_YEAR> { return TimeUnit.YEAR; }
}



/**
 * Parses a dynamic parameter marker.
 */
SqlDynamicParam DynamicParam() :
{
}
{
    <HOOK> {
        return new SqlDynamicParam(nDynamicParams++, getPos());
    }
}


/**
 * Parses a simple identifier as a string.
 */
String Identifier() :
{
    String id;
    char unicodeEscapeChar = BACKSLASH;
}
{
    (
        <IDENTIFIER>
        {
            id = unquotedIdentifier();
        }
    |
        <QUOTED_IDENTIFIER> {
            id = CoreUtil.strip(getToken(0).image, DQ, DQ, DQDQ, quotedCasing);
        }
    |
        <BACK_QUOTED_IDENTIFIER> {
            id = CoreUtil.strip(getToken(0).image, "`", "`", "``", quotedCasing);
        }
    |
        <BRACKET_QUOTED_IDENTIFIER> {
            id = CoreUtil.strip(getToken(0).image, "[", "]", "]]", quotedCasing);
        }
    |
        <UNICODE_QUOTED_IDENTIFIER> {
            id = getToken(0).image;
            id = id.substring(id.indexOf('"'));
            id = CoreUtil.strip(id, DQ, DQ, DQDQ, quotedCasing);
        }
        [
            <UESCAPE> <QUOTED_STRING> {
                String s = CoreUtil.parseString(token.image);
                unicodeEscapeChar = SqlParserUtil.checkUnicodeEscapeChar(s);
            }
        ]
        {
            SqlLiteral lit = SqlLiteral.createCharString(id, "UTF16", getPos());
            lit = lit.unescapeUnicode(unicodeEscapeChar);
            return lit.toValue();
        }
    |
        id = NonReservedKeyWord()
    )
    {
        if (id.length() > this.identifierMaxLength) {
            throw CoreUtil.newContextException(getPos(), RESOURCE.identifierTooLong(id, this.identifierMaxLength));
        }
        return id;
    }
}

/**
 * Parses a simple identifier as an SqlIdentifier.
 */
SqlIdentifier SimpleIdentifier() :
{
    final String p;
}
{
    p = Identifier() {
        return new SqlIdentifier(p, getPos());
    }
}

/**
 * Parses a comma-separated list of simple identifiers.
 */
void SimpleIdentifierCommaList(List<SqlNode> list) :
{
    SqlIdentifier id;
}
{
    id = SimpleIdentifier() {list.add(id);}
    (
        <COMMA> id = SimpleIdentifier() {
            list.add(id);
        }
    )*
}

/**
  * List of simple identifiers in parentheses. The position extends from the
  * execute parenthesis to the close parenthesis.
  */
SqlNodeList ParenthesizedSimpleIdentifierList() :
{
    final Span s;
    final List<SqlNode> list = new ArrayList<SqlNode>();
}
{
    <LPAREN> { s = span(); }
    SimpleIdentifierCommaList(list)
    <RPAREN> {
        return new SqlNodeList(list, s.end(this));
    }
}

/**
 * Parses a compound identifier.
 */
SqlIdentifier CompoundIdentifier() :
{
    List<String> list = new ArrayList<String>();
    List<ParserPos> posList = new ArrayList<ParserPos>();
    String p;
    boolean star = false;
}
{
    p = Identifier()
    {
        posList.add(getPos());
        list.add(p);
    }
    (
        <DOT>
        p = Identifier() {
            list.add(p);
            posList.add(getPos());
        }
    )*
    (
        <DOT>
        <STAR> {
            star = true;
            list.add("");
            posList.add(getPos());
        }
    )?
    {
        ParserPos pos = ParserPos.sum(posList);
        if (star) {
            return SqlIdentifier.star(list, pos, posList);
        }
        return new SqlIdentifier(list, null, pos, posList);
    }
}

/**
 * Parses a comma-separated list of compound identifiers.
 */
void CompoundIdentifierTypeCommaList(List<SqlNode> list, List<SqlNode> extendList) :
{
}
{
    CompoundIdentifierType(list, extendList)
    (<COMMA> CompoundIdentifierType(list, extendList))*
}

/**
 * List of compound identifiers in parentheses. The position extends from the
 * execute parenthesis to the close parenthesis.
 */
Pair<SqlNodeList, SqlNodeList> ParenthesizedCompoundIdentifierList() :
{
    final Span s;
    final List<SqlNode> list = new ArrayList<SqlNode>();
    final List<SqlNode> extendList = new ArrayList<SqlNode>();
}
{
    <LPAREN> { s = span(); }
    CompoundIdentifierTypeCommaList(list, extendList)
    <RPAREN> {
        return Pair.of(new SqlNodeList(list, s.end(this)), new SqlNodeList(extendList, s.end(this)));
    }
}

/**
 * Parses a NEW UDT(...) expression.
 */
SqlNode NewSpecification() :
{
    final Span s;
    final SqlNode routineCall;
}
{
    <NEW> { s = span(); }
    routineCall =
        NamedRoutineCall(FunctionCategory.USER_DEFINED_CONSTRUCTOR,
            ExprContext.ACCEPT_SUB_QUERY) {
        return (SqlCall) OperatorRegistry.get( OperatorName.NEW ).createCall(s.end(routineCall), routineCall);
    }
}

//TODO: real parse errors.
int UnsignedIntLiteral() :
{
    Token t;
}
{
    t = <UNSIGNED_INTEGER_LITERAL>
    {
        try {
            return Integer.parseInt(t.image);
        } catch (NumberFormatException ex) {
            throw generateParseException();
        }
    }
}

int IntLiteral() :
{
    Token t;
}
{
    (
        t = <UNSIGNED_INTEGER_LITERAL>
    |
        <PLUS> t = <UNSIGNED_INTEGER_LITERAL>
    )
    {
        try {
            return Integer.parseInt(t.image);
        } catch (NumberFormatException ex) {
            throw generateParseException();
        }
    }
|
    <MINUS> t = <UNSIGNED_INTEGER_LITERAL> {
        try {
            return -Integer.parseInt(t.image);
        } catch (NumberFormatException ex) {
            throw generateParseException();
        }
    }
}



// Type name with optional scale and precision
SqlDataTypeSpec DataType() :
{
    final SqlIdentifier typeName;
    SqlIdentifier collectionTypeName = null;
    int scale = -1;
    int precision = -1;
    int dimension = -1;
    int cardinality = -1;
    String charSetName = null;
    final Span s;
}
{
    typeName = TypeName() {
        s = span();
    }
    [
        <LPAREN>
        precision = UnsignedIntLiteral()
        [
            <COMMA>
            scale = UnsignedIntLiteral()
        ]
        <RPAREN>
    ]
    [
        <CHARACTER> <SET>
        charSetName = Identifier()
    ]
    [
        //e.g. ARRAY(dimension, cardinality)
        collectionTypeName = CollectionsTypeName()
        [
            <LPAREN>
            dimension = IntLiteral()
            [
                <COMMA>
                cardinality = IntLiteral()
            ]
            <RPAREN>
        ]
    ]
    {
        if (null != collectionTypeName) {
            return new SqlDataTypeSpec(
                collectionTypeName,
                typeName,
                precision,
                scale,
                dimension,
                cardinality,
                charSetName,
                s.end(collectionTypeName));
        }
        return new SqlDataTypeSpec(
            typeName,
            precision,
            scale,
            charSetName,
            null,
            s.end(this));
    }
}

// Some SQL type names need special handling due to the fact that they have
// spaces in them but are not quoted.
SqlIdentifier TypeName() :
{
    final PolyType polyType;
    final SqlIdentifier typeName;
    final Span s = Span.of();
}
{
    (
        polyType = PolyType(s) {
            typeName = new SqlIdentifier(polyType.name(), s.end(this));
        }
    |
        typeName = CollectionsTypeName()
    |
        typeName = CompoundIdentifier()
    )
    {
        return typeName;
    }
}

// Types used for JDBC and ODBC scalar conversion function
PolyType PolyType(Span s) :
{
}
{
    (<CHARACTER> | <CHAR>) { s.add(this); }
    (
        <VARYING> { return PolyType.VARCHAR; }
    |
        { return PolyType.CHAR; }
    )
|
    <VARCHAR> { return PolyType.VARCHAR; }
|
    <JSON> { return PolyType.JSON; }
|
    <DATE> { return PolyType.DATE; }
|
    <TIME> { return PolyType.TIME; }
|
    <TIMESTAMP> { return PolyType.TIMESTAMP; }
|
    <GEOMETRY> {
        if (!this.conformance.allowGeometry()) {
            throw new ParseException(RESOURCE.geometryDisabled().str());
        }
        return PolyType.GEOMETRY;
    }
|
    (<DECIMAL> | <DEC> | <NUMERIC>) { return PolyType.DECIMAL; }
|
    <BOOLEAN> { return PolyType.BOOLEAN; }
|
    ( <INTEGER> | <INT> ) { return PolyType.INTEGER; }
|
    <BINARY> { s.add(this); }
    (
        <VARYING> { return PolyType.VARBINARY; }
    |
        { return PolyType.BINARY; }
    )
|
    <VARBINARY> { return PolyType.VARBINARY; }
|
    <TINYINT> { return PolyType.TINYINT; }
|
    <SMALLINT> { return PolyType.SMALLINT; }
|
    <BIGINT> { return PolyType.BIGINT; }
|
    <REAL> { return PolyType.REAL; }
|
    <DOUBLE> { s.add(this); }
    [ <PRECISION> ] { return PolyType.DOUBLE; }
|
    <FLOAT> { return PolyType.FLOAT; }
|
    <FILE> { return PolyType.FILE; }
|
    <IMAGE> { return PolyType.IMAGE; }
|
    <VIDEO> { return PolyType.VIDEO; }
|
    <AUDIO> { return PolyType.AUDIO; }
|
    <ANY> { return PolyType.ANY; }
}

// Types used for for JDBC and ODBC scalar conversion function
SqlJdbcDataTypeName JdbcOdbcDataTypeName() :
{
}
{
    (<SQL_CHAR> | <CHAR>) { return SqlJdbcDataTypeName.SQL_CHAR; }
|   (<SQL_VARCHAR> | <VARCHAR>) { return SqlJdbcDataTypeName.SQL_VARCHAR; }
|   (<SQL_DATE> | <DATE>) { return SqlJdbcDataTypeName.SQL_DATE; }
|   (<SQL_TIME> | <TIME>) { return SqlJdbcDataTypeName.SQL_TIME; }
|   (<SQL_TIMESTAMP> | <TIMESTAMP>) { return SqlJdbcDataTypeName.SQL_TIMESTAMP; }
|   (<SQL_DECIMAL> | <DECIMAL>) { return SqlJdbcDataTypeName.SQL_DECIMAL; }
|   (<SQL_NUMERIC> | <NUMERIC>) { return SqlJdbcDataTypeName.SQL_NUMERIC; }
|   (<SQL_BOOLEAN> | <BOOLEAN>) { return SqlJdbcDataTypeName.SQL_BOOLEAN; }
|   (<SQL_INTEGER> | <INTEGER>) { return SqlJdbcDataTypeName.SQL_INTEGER; }
|   (<SQL_BINARY> | <BINARY>) { return SqlJdbcDataTypeName.SQL_BINARY; }
|   (<SQL_VARBINARY> | <VARBINARY>) { return SqlJdbcDataTypeName.SQL_VARBINARY; }
|   (<SQL_TINYINT> | <TINYINT>) { return SqlJdbcDataTypeName.SQL_TINYINT; }
|   (<SQL_SMALLINT> | <SMALLINT>) { return SqlJdbcDataTypeName.SQL_SMALLINT; }
|   (<SQL_BIGINT> | <BIGINT>) { return SqlJdbcDataTypeName.SQL_BIGINT; }
|   (<SQL_REAL>| <REAL>) { return SqlJdbcDataTypeName.SQL_REAL; }
|   (<SQL_DOUBLE> | <DOUBLE>) { return SqlJdbcDataTypeName.SQL_DOUBLE; }
|   (<SQL_FLOAT> | <FLOAT>) { return SqlJdbcDataTypeName.SQL_FLOAT; }
|   <SQL_INTERVAL_YEAR> { return SqlJdbcDataTypeName.SQL_INTERVAL_YEAR; }
|   <SQL_INTERVAL_YEAR_TO_MONTH> { return SqlJdbcDataTypeName.SQL_INTERVAL_YEAR_TO_MONTH; }
|   <SQL_INTERVAL_MONTH> { return SqlJdbcDataTypeName.SQL_INTERVAL_MONTH; }
|   <SQL_INTERVAL_DAY> { return SqlJdbcDataTypeName.SQL_INTERVAL_DAY; }
|   <SQL_INTERVAL_DAY_TO_HOUR> { return SqlJdbcDataTypeName.SQL_INTERVAL_DAY_TO_HOUR; }
|   <SQL_INTERVAL_DAY_TO_MINUTE> { return SqlJdbcDataTypeName.SQL_INTERVAL_DAY_TO_MINUTE; }
|   <SQL_INTERVAL_DAY_TO_SECOND> { return SqlJdbcDataTypeName.SQL_INTERVAL_DAY_TO_SECOND; }
|   <SQL_INTERVAL_HOUR> { return SqlJdbcDataTypeName.SQL_INTERVAL_HOUR; }
|   <SQL_INTERVAL_HOUR_TO_MINUTE> { return SqlJdbcDataTypeName.SQL_INTERVAL_HOUR_TO_MINUTE; }
|   <SQL_INTERVAL_HOUR_TO_SECOND> { return SqlJdbcDataTypeName.SQL_INTERVAL_HOUR_TO_SECOND; }
|   <SQL_INTERVAL_MINUTE> { return SqlJdbcDataTypeName.SQL_INTERVAL_MINUTE; }
|   <SQL_INTERVAL_MINUTE_TO_SECOND> { return SqlJdbcDataTypeName.SQL_INTERVAL_MINUTE_TO_SECOND; }
|   <SQL_INTERVAL_SECOND> { return SqlJdbcDataTypeName.SQL_INTERVAL_SECOND; }
|   <SQL_JSON> { return SqlJdbcDataTypeName.SQL_JSON; }
}

SqlLiteral JdbcOdbcDataType() :
{
    SqlJdbcDataTypeName typeName;
}
{
    typeName = JdbcOdbcDataTypeName() {
        return SqlLiteral.createSymbol(typeName, getPos());
    }
}

SqlIdentifier CollectionsTypeName() :
{
}
{
    <MULTISET> {
        return new SqlIdentifier(
            PolyType.MULTISET.name(), getPos());
    }
    |
    <ARRAY> {
        return new SqlIdentifier(
                    PolyType.ARRAY.name(), getPos());
    }
}

/**
 * Parses a CURSOR(query) expression.  The parser allows these
 * anywhere, but the validator restricts them to appear only as
 * arguments to table functions.
 */
SqlNode CursorExpression(ExprContext exprContext) :
{
    final SqlNode e;
    final Span s;
}
{
    <CURSOR> {
        s = span();
        if (exprContext != ExprContext.ACCEPT_ALL
                && exprContext != ExprContext.ACCEPT_CURSOR) {
            throw CoreUtil.newContextException(s.end(this),
                RESOURCE.illegalCursorExpression());
        }
    }
    e = Expression(ExprContext.ACCEPT_QUERY) {
        return (SqlCall) OperatorRegistry.get( OperatorName.CURSOR ).createCall(s.end(e), e);
    }
}

/**
 * Parses a call to a builtin function with special syntax.
 */
SqlNode BuiltinFunctionCall() :
{
    final SqlIdentifier name;
    List<SqlNode> args = null;
    SqlNode e = null;
    final Span s;
    SqlDataTypeSpec dt;
    TimeUnit interval;
    final SqlNode node;
}
{
    //~ FUNCTIONS WITH SPECIAL SYNTAX ---------------------------------------
    (
        <CAST> { s = span(); }
        <LPAREN> e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args = startList(e); }
        <AS>
        (
            dt = DataType() { args.add(dt); }
        |
            <INTERVAL> e = IntervalQualifier() { args.add(e); }
        )
        <RPAREN> {
            return (SqlCall) OperatorRegistry.get( OperatorName.CAST ).createCall(s.end(this), args);
        }
    |
        <EXTRACT> {
            s = span();
            TimeUnit unit;
        }
        <LPAREN>
        unit = TimeUnit()
        { args = startList(new SqlIntervalQualifier(unit, null, getPos())); }
        <FROM>
        e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args.add(e); }
        <RPAREN> {
            return (SqlCall) OperatorRegistry.get( OperatorName.EXTRACT ).createCall(s.end(this), args);
        }
    |
        <POSITION> { s = span(); }
        <LPAREN>
        // FIXME jvs 31-Aug-2006:  FRG-192:  This should be
        // Expression(ExprContext.ACCEPT_SUB_QUERY), but that doesn't work
        // because it matches the other kind of IN.
        e = AtomicRowExpression() { args = startList(e); }
        <IN>
        e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args.add(e);}
        [
            <FROM>
            e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args.add(e); }
        ]
        <RPAREN> {
            return (SqlCall) OperatorRegistry.get( OperatorName.POSITION ).createCall(s.end(this), args);
        }
    |
        <CONVERT> { s = span(); }
        <LPAREN>
        e = Expression(ExprContext.ACCEPT_SUB_QUERY) {
            args = startList(e);
        }
        <USING> name = SimpleIdentifier() {
            args.add(name);
        }
        <RPAREN> {
            return (SqlCall) OperatorRegistry.get( OperatorName.CONVERT ).createCall(s.end(this), args);
        }
    |
        <TRANSLATE> { s = span(); }
        <LPAREN>
        e = Expression(ExprContext.ACCEPT_SUB_QUERY) {
            args = startList(e);
        }
        (
            <USING> name = SimpleIdentifier() {
                args.add(name);
            }
            <RPAREN> {
                return (SqlCall) OperatorRegistry.get( OperatorName.TRANSLATE ).createCall(s.end(this),
                    args);
            }
        |
            (
                <COMMA> e = Expression(ExprContext.ACCEPT_SUB_QUERY) {
                    args.add(e);
                }
            )*
            <RPAREN> {
                return (SqlCall) OracleSqlOperatorTable.TRANSLATE3.createCall(
                    s.end(this), args);
            }
        )
    |
        <OVERLAY> { s = span(); }
        <LPAREN> e = Expression(ExprContext.ACCEPT_SUB_QUERY) {
            args = startList(e);
        }
        <PLACING> e = Expression(ExprContext.ACCEPT_SUB_QUERY) {
            args.add(e);
        }
        <FROM> e = Expression(ExprContext.ACCEPT_SUB_QUERY) {
            args.add(e);
        }
        [
            <FOR> e = Expression(ExprContext.ACCEPT_SUB_QUERY) {
                args.add(e);
            }
        ]
        <RPAREN> {
            return (SqlCall) OperatorRegistry.get( OperatorName.OVERLAY ).createCall(s.end(this), args);
        }
    |
        <FLOOR> { s = span(); }
        e = FloorCeilOptions(s, true) {
            return e;
        }
    |
        ( <CEIL> | <CEILING>) { s = span(); }
        e = FloorCeilOptions(s, false) {
            return e;
        }
    |
        <SUBSTRING> { s = span(); }
        <LPAREN>
        e = Expression(ExprContext.ACCEPT_SUB_QUERY)
        { args = startList(e); }
        ( <FROM> | <COMMA>)
        e = Expression(ExprContext.ACCEPT_SUB_QUERY)
        { args.add(e); }
        [
            (<FOR> | <COMMA>)
            e = Expression(ExprContext.ACCEPT_SUB_QUERY)
            { args.add(e); }
        ]
        <RPAREN> {
            return (SqlCall) OperatorRegistry.get( OperatorName.SUBSTRING ).createCall(
                s.end(this), args);
        }
    |
        <TRIM> {
            SqlLiteral flag = null;
            SqlNode trimChars = null;
            s = span();
        }
        <LPAREN>
        [
            LOOKAHEAD(2)
            [
                <BOTH> {
                    s.add(this);
                    flag = SqlLiteral.createSymbol(SqlTrimFunction.Flag.BOTH, getPos());
                }
            |
                <TRAILING> {
                    s.add(this);
                    flag =SqlLiteral.createSymbol( SqlTrimFunction.Flag.TRAILING, getPos());
                }
            |
                <LEADING> {
                    s.add(this);
                    flag = SqlLiteral.createSymbol( SqlTrimFunction.Flag.LEADING, getPos());
                }
            ]
            [ trimChars = Expression(ExprContext.ACCEPT_SUB_QUERY) ]
            (
                <FROM> {
                    if (null == flag && null == trimChars) {
                        throw CoreUtil.newContextException(getPos(),
                            RESOURCE.illegalFromEmpty());
                    }
                }
            |
                <RPAREN> {
                    // This is to handle the case of TRIM(x)
                    // (FRG-191).
                    if (flag == null) {
                        flag = SqlLiteral.createSymbol( SqlTrimFunction.Flag.BOTH, ParserPos.ZERO);
                    }
                    args = startList(flag);
                    args.add(null); // no trim chars
                    args.add(trimChars); // reinterpret trimChars as source
                    return (SqlCall) OperatorRegistry.get( OperatorName.TRIM ).createCall(s.end(this),
                        args);
                }
            )
        ]
        e = Expression(ExprContext.ACCEPT_SUB_QUERY) {
            if (flag == null) {
                flag = SqlLiteral.createSymbol(SqlTrimFunction.Flag.BOTH, ParserPos.ZERO);
            }
            args = startList(flag);
            args.add(trimChars);
            args.add(e);
        }
        <RPAREN> {
            return (SqlCall) OperatorRegistry.get( OperatorName.TRIM ).createCall(s.end(this), args);
        }
    |
        node = TimestampAddFunctionCall() { return node; }
    |
        node = TimestampDiffFunctionCall() { return node; }
    |
        node = ExtendedBuiltinFunctionCall() { return node; }
    |
        node = MatchRecognizeFunctionCall() { return node; }
    |
        node = JsonExistsFunctionCall() { return node; }
    |
        node = JsonValueFunctionCall() { return node; }
    |
        node = JsonQueryFunctionCall() { return node; }
    |
        node = JsonObjectFunctionCall() { return node; }
    |
        node = JsonObjectAggFunctionCall() { return node; }
    |
        node = JsonArrayFunctionCall() { return node; }
    |
        node = JsonArrayAggFunctionCall() { return node; }
    )
}

JsonEncoding JsonRepresentation() :
{

}
{
    <JSON>
    [
        // Encoding is currently ignored.
        <ENCODING>
        (
            <UTF8> { return JsonEncoding.UTF8; }
            |
            <UTF16> { return JsonEncoding.UTF16; }
            |
            <UTF32> { return JsonEncoding.UTF32; }
        )
    ]
    {
        return JsonEncoding.UTF8;
    }
}

void JsonInputClause() :
{

}
{
    <FORMAT> JsonRepresentation()
}

SqlDataTypeSpec JsonReturningClause() :
{
    SqlDataTypeSpec dt;
}
{
    <RETURNING> dt = DataType() { return dt; }
}

SqlDataTypeSpec JsonOutputClause() :
{
    SqlDataTypeSpec dataType;
}
{
    dataType = JsonReturningClause()
    [
        <FORMAT> JsonRepresentation()
    ]
    {
        return dataType;
    }
}

SqlNode JsonValueExpression(boolean implicitFormatJson) :
{
    SqlNode e;
    List<SqlNode> args = new ArrayList<SqlNode>();
    Span span;
}
{
    e = Expression(ExprContext.ACCEPT_NON_QUERY) {
        args.add(e);
        span = Span.of(e);
    }
    [
        JsonInputClause() {
            return (SqlCall) OperatorRegistry.get( OperatorName.JSON_VALUE_EXPRESSION ).createCall(span.end(this), args);
        }
    ]
    {
        if (implicitFormatJson) {
            return (SqlCall) OperatorRegistry.get( OperatorName.JSON_VALUE_EXPRESSION ).createCall(span.end(this), args);
        }
        return (SqlCall) OperatorRegistry.get( OperatorName.JSON_STRUCTURED_VALUE_EXPRESSION ).createCall(span.end(this), args);
    }
}

SqlNode JsonPathSpec() :
{
    SqlNode e;
}
{
    e = StringLiteral() {
        return e;
    }
}

SqlNode JsonApiCommonSyntax() :
{
    SqlNode e;
    List<SqlNode> args = new ArrayList<SqlNode>();
    Span span;
}
{
    e = JsonValueExpression(true) {
        args.add(e);
        span = Span.of(e);
    }
    <COMMA>
    e = Expression(ExprContext.ACCEPT_NON_QUERY) {
        args.add(e);
    }
    [
        <PASSING> e = JsonValueExpression(false) {
            args.add(e);
        }
        <AS> e = SimpleIdentifier() {
            args.add(e);
        }
        (
            <COMMA>
            e = JsonValueExpression(false) {
                        args.add(e);
            }
            <AS> e = SimpleIdentifier() {
                        args.add(e);
            }
        )*
    ]
    {
        return (SqlCall) OperatorRegistry.get( OperatorName.JSON_API_COMMON_SYNTAX ).createCall(span.end(this), args);
    }

}

JsonExistsErrorBehavior JsonExistsErrorBehavior() :
{

}
{
    <TRUE> { return JsonExistsErrorBehavior.TRUE; }
    |
    <FALSE> { return JsonExistsErrorBehavior.FALSE; }
    |
    <UNKNOWN> { return JsonExistsErrorBehavior.UNKNOWN; }
    |
    <ERROR> { return JsonExistsErrorBehavior.ERROR; }
}

SqlCall JsonExistsFunctionCall() :
{
    List<SqlNode> args;
    SqlNode e;
    final Span span;
    JsonExistsErrorBehavior errorBehavior;
}
{
    <JSON_EXISTS> { span = span(); }
    <LPAREN> e = JsonApiCommonSyntax() {
        args = new ArrayList<SqlNode>();
        args.add(e);
    }
    [
        errorBehavior = JsonExistsErrorBehavior() { args.add(SqlLiteral.createSymbol(errorBehavior, getPos())); }
        <ON> <ERROR>
    ]
    <RPAREN> {
        return (SqlCall) OperatorRegistry.get( OperatorName.JSON_EXISTS ).createCall(span.end(this), args);
    }
}

List<SqlNode> JsonValueEmptyOrErrorBehavior() :
{
    final List<SqlNode> list = new ArrayList<SqlNode>();
    final SqlNode e;
}
{
    (
        <ERROR> {
            list.add(SqlLiteral.createSymbol(JsonValueEmptyOrErrorBehavior.ERROR, getPos()));
            list.add(SqlLiteral.createNull(getPos()));
        }
    |
        <NULL> {
            list.add(SqlLiteral.createSymbol(JsonValueEmptyOrErrorBehavior.NULL, getPos()));
            list.add(SqlLiteral.createNull(getPos()));
        }
    |
        <DEFAULT_> e = Expression(ExprContext.ACCEPT_NON_QUERY) {
            list.add(SqlLiteral.createSymbol(JsonValueEmptyOrErrorBehavior.DEFAULT, getPos()));
            list.add(e);
        }
    )
    <ON>
    (
        <EMPTY> {
            list.add(SqlLiteral.createSymbol(JsonEmptyOrError.EMPTY, getPos()));
        }
    |
        <ERROR> {
            list.add(SqlLiteral.createSymbol(JsonEmptyOrError.ERROR, getPos()));
        }
    )
    { return list; }
}

SqlCall JsonValueFunctionCall() :
{
    final SqlNode[] args = new SqlNode[6];
    SqlNode e;
    final Span span;
    List<SqlNode> behavior;
}
{
    <JSON_VALUE> { span = span(); }
    <LPAREN> e = JsonApiCommonSyntax() {
        args[0] = e;
    }
    [
        e = JsonReturningClause() {
            args[5] = e;
        }
    ]
    (
        behavior = JsonValueEmptyOrErrorBehavior() {
            final JsonEmptyOrError symbol =
                ((SqlLiteral) behavior.get(2)).getValueAs(JsonEmptyOrError.class);
            switch (symbol) {
            case EMPTY:
                args[1] = behavior.get(0);
                args[2] = behavior.get(1);
                break;
            case ERROR:
                args[3] = behavior.get(0);
                args[4] = behavior.get(1);
                break;
            }
        }
    )*
    <RPAREN> {
        return (SqlCall) OperatorRegistry.get( OperatorName.JSON_VALUE ).createCall(span.end(this), args);
    }
}

List<SqlNode> JsonQueryEmptyOrErrorBehavior() :
{
    final List<SqlNode> list = new ArrayList<SqlNode>();
    SqlNode e;
}
{
    (
        <ERROR> {
            list.add(SqlLiteral.createSymbol(JsonQueryEmptyOrErrorBehavior.ERROR, getPos()));
        }
    |
        <NULL> {
            list.add(SqlLiteral.createSymbol(JsonQueryEmptyOrErrorBehavior.NULL, getPos()));
        }
    |
        <EMPTY> <ARRAY> {
            list.add(SqlLiteral.createSymbol(JsonQueryEmptyOrErrorBehavior.EMPTY_ARRAY, getPos()));
        }
    |
        <EMPTY> <OBJECT> {
            list.add(SqlLiteral.createSymbol(JsonQueryEmptyOrErrorBehavior.EMPTY_OBJECT, getPos()));
        }
    )
    <ON>
    (
        <EMPTY> {
            list.add(SqlLiteral.createSymbol(JsonEmptyOrError.EMPTY, getPos()));
        }
    |
        <ERROR> {
            list.add(SqlLiteral.createSymbol(JsonEmptyOrError.ERROR, getPos()));
        }
    )
    { return list; }
}

SqlNode JsonQueryWrapperBehavior() :
{
    SqlNode e;
}
{
    <WITHOUT> [<ARRAY>] {
        return SqlLiteral.createSymbol(JsonQueryWrapperBehavior.WITHOUT_ARRAY, getPos());
    }
|
    LOOKAHEAD(2)
    <WITH> <CONDITIONAL> [<ARRAY>] {
        return SqlLiteral.createSymbol(JsonQueryWrapperBehavior.WITH_CONDITIONAL_ARRAY, getPos());
    }
|
    <WITH> [<UNCONDITIONAL>] [<ARRAY>] {
        return SqlLiteral.createSymbol(JsonQueryWrapperBehavior.WITH_UNCONDITIONAL_ARRAY, getPos());
    }
}

SqlCall JsonQueryFunctionCall() :
{
    final SqlNode[] args = new SqlNode[4];
    SqlNode e;
    final Span span;
    List<SqlNode> behavior;
}
{
    <JSON_QUERY> { span = span(); }
    <LPAREN> e = JsonApiCommonSyntax() {
        args[0] = e;
    }
    [
        e = JsonQueryWrapperBehavior() <WRAPPER> {
            args[1] = e;
        }
    ]
    (
        behavior = JsonQueryEmptyOrErrorBehavior() {
            final JsonEmptyOrError symbol =
                ((SqlLiteral) behavior.get(1)).getValueAs(JsonEmptyOrError.class);
            switch (symbol) {
            case EMPTY:
                args[2] = behavior.get(0);
                break;
            case ERROR:
                args[3] = behavior.get(0);
                break;
            }
        }
    )*
    <RPAREN> {
        return (SqlCall) OperatorRegistry.get( OperatorName.JSON_QUERY ).createCall(span.end(this), args);
    }
}

SqlNode JsonName() :
{
    final SqlNode e;
}
{
     e = Expression(ExprContext.ACCEPT_NON_QUERY) {
        return e;
     }
}

List<SqlNode> JsonNameAndValue() :
{
    final List<SqlNode> list = new ArrayList<SqlNode>();
    SqlNode e;
    boolean kvMode = false;
}
{
    [
        <KEY> { kvMode = true; }
    ]
    e = JsonName() {
        list.add(e);
    }
    (
        <VALUE>
    |
        <COLON> {
            if (kvMode) {
                throw CoreUtil.newContextException(getPos(), RESOURCE.illegalColon());
            }
        }
    )
    e = JsonValueExpression(false) {
        list.add(e);
    }
    {
        return list;
    }
}

SqlNode JsonConstructorNullClause() :
{
}
{
    <NULL> <ON> <NULL> {
        return SqlLiteral.createSymbol(JsonConstructorNullClause.NULL_ON_NULL, getPos());
    }
|
    <ABSENT> <ON> <NULL> {
        return SqlLiteral.createSymbol(JsonConstructorNullClause.ABSENT_ON_NULL, getPos());
    }
}

SqlCall JsonObjectFunctionCall() :
{
    final List<SqlNode> nvArgs = new ArrayList<SqlNode>();
    final SqlNode[] otherArgs = new SqlNode[1];
    SqlNode e;
    List<SqlNode> list;
    final Span span;
}
{
    <JSON_OBJECT> { span = span(); }
    <LPAREN> [
        list = JsonNameAndValue() {
            nvArgs.addAll(list);
        }
        (
            <COMMA>
            list = JsonNameAndValue() {
                nvArgs.addAll(list);
            }
        )*
    ]
    [
        e = JsonConstructorNullClause() {
            otherArgs[0] = e;
        }
    ]
    <RPAREN> {
        final List<SqlNode> args = new ArrayList();
        args.addAll(Arrays.asList(otherArgs));
        args.addAll(nvArgs);
        return (SqlCall) OperatorRegistry.get( OperatorName.JSON_OBJECT ).createCall(span.end(this), args);
    }
}

SqlCall JsonObjectAggFunctionCall() :
{
    final SqlNode[] args = new SqlNode[2];
    List<SqlNode> list;
    final Span span;
    JsonConstructorNullClause nullClause =
        JsonConstructorNullClause.NULL_ON_NULL;
    final SqlNode e;
}
{
    <JSON_OBJECTAGG> { span = span(); }
    <LPAREN> list = JsonNameAndValue() {
        args[0] = list.get(0);
        args[1] = list.get(1);
    }
    [
        e = JsonConstructorNullClause() {
            nullClause = (JsonConstructorNullClause) ((SqlLiteral) e).value.asSymbol().value;
        }
    ]
    <RPAREN> {
        return (SqlCall) OperatorRegistry.get( OperatorName.JSON_OBJECTAGG, SqlJsonObjectAggAggFunction.class  ).with(nullClause)
            .createCall(span.end(this), args);
    }
}

SqlCall JsonArrayFunctionCall() :
{
    final List<SqlNode> elements = new ArrayList<SqlNode>();
    final SqlNode[] otherArgs = new SqlNode[1];
    SqlNode e;
    final Span span;
}
{
    <JSON_ARRAY> { span = span(); }
    <LPAREN> [
        e = JsonValueExpression(false) {
            elements.add(e);
        }
        (
            <COMMA>
            e = JsonValueExpression(false) {
                elements.add(e);
            }
        )*
    ]
    [
        e = JsonConstructorNullClause() {
            otherArgs[0] = e;
        }
    ]
    <RPAREN> {
        final List<SqlNode> args = new ArrayList();
        args.addAll(Arrays.asList(otherArgs));
        args.addAll(elements);
        return (SqlCall) OperatorRegistry.get( OperatorName.JSON_ARRAY ).createCall(span.end(this), args);
    }
}

SqlCall JsonArrayAggFunctionCall() :
{
    final SqlNode[] args = new SqlNode[1];
    List<SqlNode> list;
    final Span span;
    JsonConstructorNullClause nullClause =
        JsonConstructorNullClause.ABSENT_ON_NULL;
    SqlNode e;
}
{
    <JSON_ARRAYAGG> { span = span(); }
    <LPAREN> e = JsonValueExpression(false) {
        args[0] = e;
    }
    [
        e = JsonConstructorNullClause() {
            nullClause = (JsonConstructorNullClause) ((SqlLiteral) e).value.asSymbol().value;
        }
    ]
    <RPAREN> {
        return (SqlCall) OperatorRegistry.get( OperatorName.JSON_ARRAYAGG, SqlJsonArrayAggAggFunction.class ).with(nullClause)
            .createCall(span.end(this), args);
    }
}

/**
 * Parses a call to TIMESTAMPADD.
 */
SqlCall TimestampAddFunctionCall() :
{
    List<SqlNode> args;
    SqlNode e;
    final Span s;
    TimeUnit interval;
    SqlNode node;
}
{
    <TIMESTAMPADD> { s = span(); }
    <LPAREN>
    interval = TimestampInterval() {
        args = startList(SqlLiteral.createSymbol(interval, getPos()));
    }
    <COMMA>
    e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args.add(e); }
    <COMMA>
    e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args.add(e); }
    <RPAREN> {
        return (SqlCall) OperatorRegistry.get( OperatorName.TIMESTAMP_ADD ).createCall(
            s.end(this), args);
    }
}

/**
 * Parses a call to TIMESTAMPDIFF.
 */
SqlCall TimestampDiffFunctionCall() :
{
    List<SqlNode> args;
    SqlNode e;
    final Span s;
    TimeUnit interval;
    SqlNode node;
}
{
    <TIMESTAMPDIFF> { s = span(); }
    <LPAREN>
    interval = TimestampInterval() {
        args = startList(SqlLiteral.createSymbol(interval, getPos()));
    }
    <COMMA>
    e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args.add(e); }
    <COMMA>
    e = Expression(ExprContext.ACCEPT_SUB_QUERY) { args.add(e); }
    <RPAREN> {
        return (SqlCall) OperatorRegistry.get( OperatorName.TIMESTAMP_DIFF ).createCall(
            s.end(this), args);
    }
}

SqlCall MatchRecognizeFunctionCall() :
{
    final SqlCall func;
    final Span s;
}
{
    (
        <CLASSIFIER> { s = span(); } <LPAREN> <RPAREN> {
            func = (SqlCall) OperatorRegistry.get( OperatorName.CLASSIFIER ).createCall(s.end(this));
        }
    |
        <MATCH_NUMBER> { s = span(); } <LPAREN> <RPAREN> {
            func = (SqlCall) OperatorRegistry.get( OperatorName.MATCH_NUMBER ).createCall(s.end(this));
        }
    |
        func = MatchRecognizeNavigationLogical()
    |
        func = MatchRecognizeNavigationPhysical()
    |
        func = MatchRecognizeCallWithModifier()
    )
    { return func; }
}

SqlCall MatchRecognizeCallWithModifier() :
{
    final Span s;
    final SqlOperator runningOp;
    final SqlNode func;
}
{
    (
        <RUNNING> { runningOp = OperatorRegistry.get( OperatorName.RUNNING, SqlOperator.class ); }
    |
        <FINAL> { runningOp = OperatorRegistry.get( OperatorName.FINAL, SqlOperator.class ); }
    )
    { s = span(); }
    func = NamedFunctionCall() {
        return (SqlCall) runningOp.createCall(s.end(func), func);
    }
}

SqlCall MatchRecognizeNavigationLogical() :
{
    final Span s = Span.of();
    SqlCall func;
    final SqlOperator funcOp;
    final SqlOperator runningOp;
    SqlNode arg0;
    SqlNode arg1 = SqlLiteral.createExactNumeric("0", ParserPos.ZERO);
}
{
    (
        <RUNNING> { runningOp = OperatorRegistry.get( OperatorName.RUNNING, SqlOperator.class ); s.add(this); }
    |
        <FINAL> { runningOp = OperatorRegistry.get( OperatorName.FINAL, SqlOperator.class ); s.add(this); }
    |
        { runningOp = null; }
    )
    (
        <FIRST> { funcOp = OperatorRegistry.get( OperatorName.FIRST, SqlOperator.class ); }
    |
        <LAST> { funcOp = OperatorRegistry.get( OperatorName.LAST, SqlOperator.class ); }
    )
    { s.add(this); }
    <LPAREN>
    arg0 = Expression(ExprContext.ACCEPT_SUB_QUERY)
    [ <COMMA> arg1 = NumericLiteral() ]
    <RPAREN> {
        func = (SqlCall) funcOp.createCall(s.end(this), arg0, arg1);
        if (runningOp != null) {
            return (SqlCall) runningOp.createCall(s.end(this), func);
        } else {
            return func;
        }
    }
}

SqlCall MatchRecognizeNavigationPhysical() :
{
    final Span s;
    SqlCall func;
    SqlOperator funcOp;
    SqlNode arg0;
    SqlNode arg1 = SqlLiteral.createExactNumeric("1", ParserPos.ZERO);
}
{
    (
        <PREV> { funcOp = OperatorRegistry.get( OperatorName.PREV, SqlOperator.class ); }
    |
        <NEXT> { funcOp = OperatorRegistry.get( OperatorName.NEXT, SqlOperator.class ); }
    )
    { s = span(); }
    <LPAREN>
    arg0 = Expression(ExprContext.ACCEPT_SUB_QUERY)
    [ <COMMA> arg1 = NumericLiteral() ]
    <RPAREN> {
        return (SqlCall) funcOp.createCall(s.end(this), arg0, arg1);
    }
}

/**
 * Parses a call to a named function (could be a builtin with regular
 * syntax, or else a UDF).
 *
 * <p>NOTE: every UDF has two names: an <em>invocation name</em> and a
 * <em>specific name</em>.  Normally, function calls are resolved via overload
 * resolution and invocation names.  The SPECIFIC prefix allows overload
 * resolution to be bypassed.  Note that usage of the SPECIFIC prefix in
 * queries is non-standard; it is used internally by Farrago, e.g. in stored
 * view definitions to permanently bind references to a particular function
 * after the overload resolution performed by view creation.
 *
 * <p>TODO jvs 25-Mar-2005:  Once we have SQL-Flagger support, flag SPECIFIC
 * as non-standard.
 */
SqlNode NamedFunctionCall() :
{
    final FunctionCategory funcType;
    final SqlIdentifier qualifiedName;
    final Span s;
    final List<SqlNode> args;
    SqlCall call;
    final Span filterSpan;
    final SqlNode filter;
    final SqlNode over;
    SqlLiteral quantifier = null;
    SqlNodeList orderList = null;
    final Span withinGroupSpan;
}
{
    (
        <SPECIFIC> {
            funcType = FunctionCategory.USER_DEFINED_SPECIFIC_FUNCTION;
        }
    |
        { funcType = FunctionCategory.USER_DEFINED_FUNCTION; }
    )
    qualifiedName = FunctionName() {
        s = span();
    }
    (
        LOOKAHEAD(2) <LPAREN> <STAR> {
            args = startList(SqlIdentifier.star(getPos()));
        }
        <RPAREN>
    |
        LOOKAHEAD(2) <LPAREN> <RPAREN> {
            args = Collections.emptyList();
        }
    |
        args = FunctionParameterList(ExprContext.ACCEPT_SUB_QUERY) {
            quantifier = (SqlLiteral) args.get(0);
            args.remove(0);
        }
    )
    {
        call = createCall(qualifiedName, s.end(this), funcType, quantifier, args);
    }
    [
        <WITHIN> { withinGroupSpan = span(); }
        <GROUP>
        <LPAREN>
        orderList = OrderBy(true)
        <RPAREN> {
            call = (SqlCall) OperatorRegistry.get( OperatorName.WITHIN_GROUP ).createCall(
                withinGroupSpan.end(this), call, orderList);
        }
    ]
    [
        <FILTER> { filterSpan = span(); }
        <LPAREN>
        <WHERE>
        filter = Expression(ExprContext.ACCEPT_SUB_QUERY)
        <RPAREN> {
            call = (SqlCall) OperatorRegistry.get( OperatorName.FILTER ).createCall(
                filterSpan.end(this), call, filter);
        }
    ]
    [
        <OVER>
        (
            over = SimpleIdentifier()
        |
            over = WindowSpecification()
        )
        {
            call = (SqlCall) OperatorRegistry.get( OperatorName.OVER ).createCall(s.end(over), call, over);
        }
    ]
    {
        return call;
    }
}


/*
* Parse Floor/Ceil function parameters
*/
SqlNode StandardFloorCeilOptions(Span s, boolean floorFlag) :
{
    SqlNode e;
    final List<SqlNode> args;
    TimeUnit unit;
    SqlCall function;
    final Span s1;
}
{
    <LPAREN> e = Expression(ExprContext.ACCEPT_SUB_QUERY) {
        args = startList(e);
    }
    (
        <TO>
        unit = TimeUnit() {
            args.add(new SqlIntervalQualifier(unit, null, getPos()));
        }
    )?
    <RPAREN> {
        SqlOperator op = floorFlag
            ? OperatorRegistry.get( OperatorName.FLOOR, SqlOperator.class )
            : OperatorRegistry.get( OperatorName.CEIL, SqlOperator.class );
        function =  (SqlCall) op.createCall(s.end(this), args);
    }
    (
        <OVER> { s1 = span(); }
        (
            e = SimpleIdentifier()
        |
            e = WindowSpecification()
        )
        {
            return (SqlCall) OperatorRegistry.get( OperatorName.OVER ).createCall(s1.end(this), function, e);
        }
    |
        { return function; }
    )
}

/**
 * Parses the name of a JDBC function that is a token but is not reserved.
 */
String NonReservedJdbcFunctionName() :
{
}
{
    (
        <SUBSTRING>
    )
    {
        return unquotedIdentifier();
    }
}

/**
 * Parses the name of a function (either a compound identifier or
 * a reserved word which can be used as a function name).
 */
SqlIdentifier FunctionName() :
{
    SqlIdentifier qualifiedName;
}
{
    (
        qualifiedName = CompoundIdentifier()
    |
        qualifiedName = ReservedFunctionName()
    )
    {
        return qualifiedName;
    }
}

/**
 * Parses a reserved word which is used as the name of a function.
 */
SqlIdentifier ReservedFunctionName() :
{
}
{
    (
        <ABS>
    |   <AVG>
    |   <CARDINALITY>
    |   <CEILING>
    |   <CHAR_LENGTH>
    |   <CHARACTER_LENGTH>
    |   <COALESCE>
    |   <COLLECT>
    |   <COVAR_POP>
    |   <COVAR_SAMP>
    |   <CUME_DIST>
    |   <COUNT>
    |   <CURRENT_DATE>
    |   <CURRENT_TIME>
    |   <CURRENT_TIMESTAMP>
    |   <DENSE_RANK>
    |   <ELEMENT>
    |   <EXP>
    |   <FIRST_VALUE>
    |   <FLOOR>
    |   <FUSION>
    |   <GROUPING>
    |   <HOUR>
    |   <DISTANCE>
    |   <LAG>
    |   <LEAD>
    |   <LAST_VALUE>
    |   <LN>
    |   <LOCALTIME>
    |   <LOCALTIMESTAMP>
    |   <LOWER>
    |   <MAX>
    |   <META>
    |   <MIN>
    |   <MINUTE>
    |   <MOD>
    |   <MONTH>
    |   <NTH_VALUE>
    |   <NTILE>
    |   <NULLIF>
    |   <OCTET_LENGTH>
    |   <PERCENT_RANK>
    |   <POWER>
    |   <RANK>
    |   <REGR_COUNT>
    |   <REGR_SXX>
    |   <REGR_SYY>
    |   <ROW_NUMBER>
    |   <SECOND>
    |   <SQRT>
    |   <STDDEV_POP>
    |   <STDDEV_SAMP>
    |   <SUM>
    |   <UPPER>
    |   <TRUNCATE>
    |   <USER>
    |   <VAR_POP>
    |   <VAR_SAMP>
    |   <YEAR>
    )
    {
        return new SqlIdentifier(unquotedIdentifier(), getPos());
    }
}

SqlIdentifier ContextVariable() :
{
}
{
    (
        <CURRENT_CATALOG>
    |   <CURRENT_DATE>
    |   <CURRENT_DEFAULT_TRANSFORM_GROUP>
    |   <CURRENT_PATH>
    |   <CURRENT_ROLE>
    |   <CURRENT_SCHEMA>
    |   <CURRENT_TIME>
    |   <CURRENT_TIMESTAMP>
    |   <CURRENT_USER>
    |   <LOCALTIME>
    |   <LOCALTIMESTAMP>
    |   <SESSION_USER>
    |   <SYSTEM_USER>
    |   <USER>
    )
    {
        return new SqlIdentifier(unquotedIdentifier(), getPos());
    }
}

/**
 * Parses a function call expression with JDBC syntax.
 */
SqlNode JdbcFunctionCall() :
{
    String name;
    SqlIdentifier id;
    SqlNode e;
    SqlLiteral tl;
    SqlNodeList args;
    SqlCall call;
    final Span s, s1;
}
{
    <LBRACE_FN> {
        s = span();
    }
    (
        LOOKAHEAD(1)
        call = TimestampAddFunctionCall() {
            name = call.getOperator().getName();
            args = new SqlNodeList(call.getSqlOperandList(), getPos());
        }
    |
        call = TimestampDiffFunctionCall() {
            name = call.getOperator().getName();
            args = new SqlNodeList(call.getSqlOperandList(), getPos());
        }
    |
        <CONVERT> { name = unquotedIdentifier(); }
        <LPAREN>
        e = Expression(ExprContext.ACCEPT_SUB_QUERY) {
            args = new SqlNodeList(getPos());
            args.add(e);
        }
        <COMMA>
        tl = JdbcOdbcDataType() { args.add(tl); }
        <RPAREN>
    |
        (
            // INSERT is a reserved word, but we need to handle {fn insert}
            <INSERT> { name = unquotedIdentifier(); }
        |
            // TRUNCATE is a reserved word, but we need to handle {fn truncate}
            <TRUNCATE> { name = unquotedIdentifier(); }
        |
            // For cases like {fn power(1,2)} and {fn lower('a')}
            id = ReservedFunctionName() { name = id.getSimple(); }
        |
            // For cases like {fn substring('foo', 1,2)}
            name = NonReservedJdbcFunctionName()
        |
            name = Identifier()
        )
        (
            LOOKAHEAD(2) <LPAREN> <STAR> { s1 = span(); } <RPAREN>
            {
                args = new SqlNodeList(s1.pos());
                args.add(SqlIdentifier.star(s1.pos()));
            }
        |
            LOOKAHEAD(2) <LPAREN> <RPAREN> { args = SqlNodeList.EMPTY; }
        |
            args = ParenthesizedQueryOrCommaList(ExprContext.ACCEPT_SUB_QUERY)
        )
    )
    <RBRACE> {
        return (SqlCall) new SqlJdbcFunctionCall(name).createCall(s.end(this), args.getList());
    }
}

/**
 * Parses a binary query operator like UNION.
 */
SqlBinaryOperator BinaryQueryOperator() :
{
}
{
    // If both the ALL or DISTINCT keywords are missing, DISTINCT is implicit.
    (
        <UNION>
        (
            <ALL> { return OperatorRegistry.get( OperatorName.UNION_ALL, SqlBinaryOperator.class ); }
        |   <DISTINCT> { return OperatorRegistry.get( OperatorName.UNION, SqlBinaryOperator.class ); }
        |   { return OperatorRegistry.get( OperatorName.UNION, SqlBinaryOperator.class ); }
        )
    |
        <INTERSECT>
        (
            <ALL> { return OperatorRegistry.get( OperatorName.INTERSECT_ALL, SqlBinaryOperator.class ); }
        |   <DISTINCT> { return OperatorRegistry.get( OperatorName.INTERSECT, SqlBinaryOperator.class ); }
        |   { return OperatorRegistry.get( OperatorName.INTERSECT, SqlBinaryOperator.class ); }
        )
    |
        (
            <EXCEPT>
        |
            <SET_MINUS> {
                if (!this.conformance.isMinusAllowed()) {
                    throw new ParseException(RESOURCE.minusNotAllowed().str());
                }
            }
        )
        (
            <ALL> { return OperatorRegistry.get( OperatorName.EXCEPT_ALL, SqlBinaryOperator.class ); }
        |   <DISTINCT> { return OperatorRegistry.get( OperatorName.EXCEPT, SqlBinaryOperator.class ); }
        |   { return OperatorRegistry.get( OperatorName.EXCEPT, SqlBinaryOperator.class ); }
        )
    )
}

/**
 * Parses a binary multiset operator.
 */
SqlBinaryOperator BinaryMultisetOperator() :
{
}
{
    // If both the ALL or DISTINCT keywords are missing, DISTINCT is implicit
    <MULTISET>
    (
        <UNION>
        [
            <ALL>
        |   <DISTINCT> { return OperatorRegistry.get( OperatorName.MULTISET_UNION_DISTINCT, SqlBinaryOperator.class ); }
        ]
        { return OperatorRegistry.get( OperatorName.MULTISET_UNION, SqlBinaryOperator.class  ); }
    |
        <INTERSECT>
        [
            <ALL>
        |   <DISTINCT> { return OperatorRegistry.get( OperatorName.MULTISET_INTERSECT_DISTINCT, SqlBinaryOperator.class ); }
        ]
        { return OperatorRegistry.get( OperatorName.MULTISET_INTERSECT, SqlBinaryOperator.class ); }
    |
        <EXCEPT>
        [
            <ALL>
        |   <DISTINCT> { return OperatorRegistry.get( OperatorName.MULTISET_EXCEPT_DISTINCT, SqlBinaryOperator.class ); }
        ]
        { return OperatorRegistry.get( OperatorName.MULTISET_EXCEPT, SqlBinaryOperator.class ); }
    )
}

/**
 * Parses a binary row operator like AND.
 */
SqlBinaryOperator BinaryRowOperator() :
{
    SqlBinaryOperator op;
}
{
    // <IN> is handled as a special case
    <EQ> { return OperatorRegistry.get( OperatorName.EQUALS, SqlBinaryOperator.class ); }
|   <GT> { return OperatorRegistry.get( OperatorName.GREATER_THAN, SqlBinaryOperator.class ); }
|   <LT> { return OperatorRegistry.get( OperatorName.LESS_THAN, SqlBinaryOperator.class ); }
|   <LE> { return OperatorRegistry.get( OperatorName.LESS_THAN_OR_EQUAL, SqlBinaryOperator.class ); }
|   <GE> { return OperatorRegistry.get( OperatorName.GREATER_THAN_OR_EQUAL, SqlBinaryOperator.class ); }
|   <NE> { return OperatorRegistry.get( OperatorName.NOT_EQUALS, SqlBinaryOperator.class ); }
|   <NE2> {
        if (!this.conformance.isBangEqualAllowed()) {
            throw new ParseException(RESOURCE.bangEqualNotAllowed().str());
        }
        return OperatorRegistry.get( OperatorName.NOT_EQUALS, SqlBinaryOperator.class );
    }
|   <PLUS> { return OperatorRegistry.get( OperatorName.PLUS, SqlBinaryOperator.class ); }
|   <MINUS> { return OperatorRegistry.get( OperatorName.MINUS, SqlBinaryOperator.class ); }
|   <STAR> { return OperatorRegistry.get( OperatorName.MULTIPLY, SqlBinaryOperator.class ); }
|   <SLASH> { return OperatorRegistry.get( OperatorName.DIVIDE, SqlBinaryOperator.class ); }
|   <PERCENT_REMAINDER> {
        if (!this.conformance.isPercentRemainderAllowed()) {
            throw new ParseException(RESOURCE.percentRemainderNotAllowed().str());
        }
        return OperatorRegistry.get( OperatorName.PERCENT_REMAINDER, SqlBinaryOperator.class );
    }
|   <CONCAT> { return OperatorRegistry.get( OperatorName.CONCAT, SqlBinaryOperator.class ); }
|   <AND> { return OperatorRegistry.get( OperatorName.AND, SqlBinaryOperator.class ); }
|   <OR> { return OperatorRegistry.get( OperatorName.OR, SqlBinaryOperator.class ); }
|   LOOKAHEAD(2) <IS> <DISTINCT> <FROM> { return OperatorRegistry.get( OperatorName.IS_DISTINCT_FROM, SqlBinaryOperator.class ); }
|   <IS> <NOT> <DISTINCT> <FROM> { return OperatorRegistry.get( OperatorName.IS_NOT_DISTINCT_FROM, SqlBinaryOperator.class ); }
|   <MEMBER> <OF> { return OperatorRegistry.get( OperatorName.MEMBER_OF, SqlBinaryOperator.class ); }
|   LOOKAHEAD(2) <SUBMULTISET> <OF> { return OperatorRegistry.get( OperatorName.SUBMULTISET_OF, SqlBinaryOperator.class ); }
|   <NOT> <SUBMULTISET> <OF> { return OperatorRegistry.get( OperatorName.NOT_SUBMULTISET_OF, SqlBinaryOperator.class ); }
|   <CONTAINS> { return OperatorRegistry.get( OperatorName.CONTAINS, SqlBinaryOperator.class ); }
|   <OVERLAPS> { return OperatorRegistry.get( OperatorName.OVERLAPS, SqlBinaryOperator.class ); }
|   <EQUALS> { return OperatorRegistry.get( OperatorName.PERIOD_EQUALS, SqlBinaryOperator.class ); }
|   <PRECEDES> { return OperatorRegistry.get( OperatorName.PRECEDES, SqlBinaryOperator.class ); }
|   <SUCCEEDS> { return OperatorRegistry.get( OperatorName.SUCCEEDS, SqlBinaryOperator.class ); }
|   <IMMEDIATELY> <PRECEDES> { return OperatorRegistry.get( OperatorName.IMMEDIATELY_PRECEDES, SqlBinaryOperator.class ); }
|   <IMMEDIATELY> <SUCCEEDS> { return OperatorRegistry.get( OperatorName.IMMEDIATELY_SUCCEEDS, SqlBinaryOperator.class ); }
|   op = BinaryMultisetOperator() { return op; }
}

/**
 * Parses a prefix row operator like NOT.
 */
SqlPrefixOperator PrefixRowOperator() :
{}
{
    <PLUS> { return OperatorRegistry.get( OperatorName.UNARY_PLUS, SqlPrefixOperator.class ); }
|   <MINUS> { return OperatorRegistry.get( OperatorName.UNARY_MINUS, SqlPrefixOperator.class ); }
|   <NOT> { return OperatorRegistry.get( OperatorName.NOT, SqlPrefixOperator.class ); }
|   <EXISTS> { return OperatorRegistry.get( OperatorName.EXISTS, SqlPrefixOperator.class ); }
}

/**
 * Parses a postfix row operator like IS NOT NULL.
 */
SqlPostfixOperator PostfixRowOperator() :
{}
{
    <IS>
    (
        <A> <SET> { return OperatorRegistry.get( OperatorName.IS_A_SET, SqlPostfixOperator.class ); }
    |
        <NOT>
        (
            <NULL> { return OperatorRegistry.get( OperatorName.IS_NOT_NULL, SqlPostfixOperator.class ); }
        |   <TRUE> { return OperatorRegistry.get( OperatorName.IS_NOT_TRUE, SqlPostfixOperator.class ); }
        |   <FALSE> { return OperatorRegistry.get( OperatorName.IS_NOT_FALSE, SqlPostfixOperator.class ); }
        |   <UNKNOWN> { return OperatorRegistry.get( OperatorName.IS_NOT_UNKNOWN, SqlPostfixOperator.class ); }
        |   <A> <SET> { return OperatorRegistry.get( OperatorName.IS_NOT_A_SET, SqlPostfixOperator.class ); }
        |   <EMPTY> { return OperatorRegistry.get( OperatorName.IS_NOT_EMPTY, SqlPostfixOperator.class ); }
        |   LOOKAHEAD(2) <JSON> <VALUE> { return OperatorRegistry.get( OperatorName.IS_NOT_JSON_VALUE, SqlPostfixOperator.class ); }
        |   LOOKAHEAD(2) <JSON> <OBJECT> { return OperatorRegistry.get( OperatorName.IS_NOT_JSON_OBJECT, SqlPostfixOperator.class ); }
        |   LOOKAHEAD(2) <JSON> <ARRAY> { return OperatorRegistry.get( OperatorName.IS_NOT_JSON_ARRAY, SqlPostfixOperator.class ); }
        |   LOOKAHEAD(2) <JSON> <SCALAR> { return OperatorRegistry.get( OperatorName.IS_NOT_JSON_SCALAR, SqlPostfixOperator.class ); }
        |   <JSON> { return OperatorRegistry.get( OperatorName.IS_NOT_JSON_VALUE, SqlPostfixOperator.class ); }
        )
    |
        (
            <NULL> { return OperatorRegistry.get( OperatorName.IS_NULL, SqlPostfixOperator.class ); }
        |   <TRUE> { return OperatorRegistry.get( OperatorName.IS_TRUE, SqlPostfixOperator.class ); }
        |   <FALSE> { return OperatorRegistry.get( OperatorName.IS_FALSE, SqlPostfixOperator.class ); }
        |   <UNKNOWN> { return OperatorRegistry.get( OperatorName.IS_UNKNOWN, SqlPostfixOperator.class ); }
        |   <EMPTY> { return OperatorRegistry.get( OperatorName.IS_EMPTY, SqlPostfixOperator.class ); }
        |   LOOKAHEAD(2) <JSON> <VALUE> { return OperatorRegistry.get( OperatorName.IS_JSON_VALUE, SqlPostfixOperator.class ); }
        |   LOOKAHEAD(2) <JSON> <OBJECT> { return OperatorRegistry.get( OperatorName.IS_JSON_OBJECT, SqlPostfixOperator.class ); }
        |   LOOKAHEAD(2) <JSON> <ARRAY> { return OperatorRegistry.get( OperatorName.IS_JSON_ARRAY, SqlPostfixOperator.class ); }
        |   LOOKAHEAD(2) <JSON> <SCALAR> { return OperatorRegistry.get( OperatorName.IS_JSON_SCALAR, SqlPostfixOperator.class ); }
        |   <JSON> { return OperatorRegistry.get( OperatorName.IS_JSON_VALUE, SqlPostfixOperator.class ); }
        )
    )
}


/* KEYWORDS:  anything in this list is a reserved word unless it appears
   in the NonReservedKeyWord() production. */

<DEFAULT, DQID, BTID> TOKEN :
{
    < A: "A" >
|   < ABS: "ABS" >
|   < ABSENT: "ABSENT" >
|   < ABSOLUTE: "ABSOLUTE" >
|   < ACTION: "ACTION" >
|   < ADA: "ADA" >
|   < ADAPTERS: "ADAPTERS" >
|   < ADD: "ADD" >
|   < ADMIN: "ADMIN" >
|   < AFTER: "AFTER" >
|   < ALL: "ALL" >
|   < ALLOCATE: "ALLOCATE" >
|   < ALLOW: "ALLOW" >
|   < ALTER: "ALTER" >
|   < ALWAYS: "ALWAYS" >
|   < AND: "AND" >
|   < ANY: "ANY" >
|   < APPLY: "APPLY" >
|   < ARE: "ARE" >
|   < ARRAY: "ARRAY" >
|   < ARRAY_MAX_CARDINALITY: "ARRAY_MAX_CARDINALITY" >
|   < AS: "AS" >
|   < ASC: "ASC" >
|   < ASENSITIVE: "ASENSITIVE" >
|   < ASSERTION: "ASSERTION" >
|   < ASSIGNMENT: "ASSIGNMENT" >
|   < ASYMMETRIC: "ASYMMETRIC" >
|   < AT: "AT" >
|   < ATOMIC: "ATOMIC" >
|   < ATTRIBUTE: "ATTRIBUTE" >
|   < ATTRIBUTES: "ATTRIBUTES" >
|   < AUTHORIZATION: "AUTHORIZATION" >
|   < AVG: "AVG" >
|   < BEFORE: "BEFORE" >
|   < BEGIN: "BEGIN" >
|   < BEGIN_FRAME: "BEGIN_FRAME" >
|   < BEGIN_PARTITION: "BEGIN_PARTITION" >
|   < BERNOULLI: "BERNOULLI" >
|   < BETWEEN: "BETWEEN" >
|   < BIGINT: "BIGINT" >
|   < BINARY: "BINARY" >
|   < BIT: "BIT" >
|   < BLOB: "BLOB" >
|   < BOOLEAN: "BOOLEAN" >
|   < BOTH: "BOTH" >
|   < BREADTH: "BREADTH" >
|   < BY: "BY" >
|   < C: "C" >
|   < CALL: "CALL" >
|   < CALLED: "CALLED" >
|   < CARDINALITY: "CARDINALITY" >
|   < CASCADE: "CASCADE" >
|   < CASCADED: "CASCADED" >
|   < CASE: "CASE" >
|   < CAST: "CAST" >
|   < CATALOG: "CATALOG" >
|   < CATALOG_NAME: "CATALOG_NAME" >
|   < CEIL: "CEIL" >
|   < CEILING: "CEILING" >
|   < CENTURY: "CENTURY" >
|   < CHAIN: "CHAIN" >
|   < CHAR: "CHAR" >
|   < CHAR_LENGTH: "CHAR_LENGTH" >
|   < CHARACTER: "CHARACTER" >
|   < CHARACTER_LENGTH: "CHARACTER_LENGTH" >
|   < CHARACTER_SET_CATALOG: "CHARACTER_SET_CATALOG" >
|   < CHARACTER_SET_NAME: "CHARACTER_SET_NAME" >
|   < CHARACTER_SET_SCHEMA: "CHARACTER_SET_SCHEMA" >
|   < CHARACTERISTICS: "CHARACTERISTICS" >
|   < CHARACTERS: "CHARACTERS" >
|   < CHECK: "CHECK" >
|   < CLASSIFIER: "CLASSIFIER" >
|   < CLASS_ORIGIN: "CLASS_ORIGIN" >
|   < CLOB: "CLOB" >
|   < CLOSE: "CLOSE" >
|   < COALESCE: "COALESCE" >
|   < COBOL: "COBOL" >
|   < COLLATE: "COLLATE" >
|   < COLLATION: "COLLATION" >
|   < COLLATION_CATALOG: "COLLATION_CATALOG" >
|   < COLLATION_NAME: "COLLATION_NAME" >
|   < COLLATION_SCHEMA: "COLLATION_SCHEMA" >
|   < COLLECT: "COLLECT" >
|   < COLUMN: "COLUMN" >
|   < COLUMN_NAME: "COLUMN_NAME" >
|   < COMMAND_FUNCTION: "COMMAND_FUNCTION" >
|   < COMMAND_FUNCTION_CODE: "COMMAND_FUNCTION_CODE" >
|   < COMMIT: "COMMIT" >
|   < COMMITTED: "COMMITTED" >
|   < CONDITION: "CONDITION" >
|   < CONDITIONAL: "CONDITIONAL" >
|   < CONDITION_NUMBER: "CONDITION_NUMBER" >
|   < CONFIG: "CONFIG" >
|   < CONNECT: "CONNECT" >
|   < CONNECTION: "CONNECTION" >
|   < CONNECTION_NAME: "CONNECTION_NAME" >
|   < CONSTRAINT: "CONSTRAINT" >
|   < CONSTRAINT_CATALOG: "CONSTRAINT_CATALOG" >
|   < CONSTRAINT_NAME: "CONSTRAINT_NAME" >
|   < CONSTRAINT_SCHEMA: "CONSTRAINT_SCHEMA" >
|   < CONSTRAINTS: "CONSTRAINTS" >
|   < CONSTRUCTOR: "CONSTRUCTOR" >
|   < CONTAINS: "CONTAINS" >
|   < CONTINUE: "CONTINUE" >
|   < CONVERT: "CONVERT" >
|   < CORR: "CORR" >
|   < CORRESPONDING: "CORRESPONDING" >
|   < COUNT: "COUNT" >
|   < COVAR_POP: "COVAR_POP" >
|   < COVAR_SAMP: "COVAR_SAMP" >
|   < CREATE: "CREATE" >
|   < CROSS: "CROSS" >
|   < CUBE: "CUBE" >
|   < CUME_DIST: "CUME_DIST" >
|   < CURRENT: "CURRENT" >
|   < CURRENT_CATALOG: "CURRENT_CATALOG" >
|   < CURRENT_DATE: "CURRENT_DATE" >
|   < CURRENT_DEFAULT_TRANSFORM_GROUP: "CURRENT_DEFAULT_TRANSFORM_GROUP" >
|   < CURRENT_PATH: "CURRENT_PATH" >
|   < CURRENT_ROLE: "CURRENT_ROLE" >
|   < CURRENT_ROW: "CURRENT_ROW" >
|   < CURRENT_SCHEMA: "CURRENT_SCHEMA" >
|   < CURRENT_TIME: "CURRENT_TIME" >
|   < CURRENT_TIMESTAMP: "CURRENT_TIMESTAMP" >
|   < CURRENT_TRANSFORM_GROUP_FOR_TYPE: "CURRENT_TRANSFORM_GROUP_FOR_TYPE" >
|   < CURRENT_USER: "CURRENT_USER" >
|   < CURSOR: "CURSOR" >
|   < CURSOR_NAME: "CURSOR_NAME" >
|   < CYCLE: "CYCLE" >
|   < DATA: "DATA" >
|   < DATABASE: "DATABASE" >
|   < DATE: "DATE" >
|   < DATETIME_INTERVAL_CODE: "DATETIME_INTERVAL_CODE" >
|   < DATETIME_INTERVAL_PRECISION: "DATETIME_INTERVAL_PRECISION" >
|   < DAY: "DAY" >
|   < DEALLOCATE: "DEALLOCATE" >
|   < DEC: "DEC" >
|   < DECADE: "DECADE" >
|   < DECIMAL: "DECIMAL" >
|   < DECLARE: "DECLARE" >
|   < DEFAULT_: "DEFAULT" >
|   < DEFAULTS: "DEFAULTS" >
|   < DEFERRABLE: "DEFERRABLE" >
|   < DEFERRED: "DEFERRED" >
|   < DEFINE: "DEFINE" >
|   < DEFINED: "DEFINED" >
|   < DEFINER: "DEFINER" >
|   < DEGREE: "DEGREE" >
|   < DELETE: "DELETE" >
|   < DENSE_RANK: "DENSE_RANK" >
|   < DEPTH: "DEPTH" >
|   < DEREF: "DEREF" >
|   < DERIVED: "DERIVED" >
|   < DESC: "DESC" >
|   < DESCRIBE: "DESCRIBE" >
|   < DESCRIPTION: "DESCRIPTION" >
|   < DESCRIPTOR: "DESCRIPTOR" >
|   < DETERMINISTIC: "DETERMINISTIC" >
|   < DIAGNOSTICS: "DIAGNOSTICS" >
|   < DISALLOW: "DISALLOW" >
|   < DISCONNECT: "DISCONNECT" >
|   < DISPATCH: "DISPATCH" >
|   < DISTINCT: "DISTINCT" >
|   < DOCUMENT: "DOCUMENT" >
|   < DOMAIN: "DOMAIN" >
|   < DOUBLE: "DOUBLE" >
|   < DOW: "DOW" >
|   < DOY: "DOY" >
|   < DROP: "DROP" >
|   < DYNAMIC: "DYNAMIC" >
|   < DYNAMIC_FUNCTION: "DYNAMIC_FUNCTION" >
|   < DYNAMIC_FUNCTION_CODE: "DYNAMIC_FUNCTION_CODE" >
|   < EACH: "EACH" >
|   < ELEMENT: "ELEMENT" >
|   < ELSE: "ELSE" >
|   < EMPTY: "EMPTY" >
|   < ENCODING: "ENCODING">
|   < END: "END" >
|   < END_EXEC: "END-EXEC" >
|   < END_FRAME: "END_FRAME" >
|   < END_PARTITION: "END_PARTITION" >
|   < EPOCH: "EPOCH" >
|   < EQUALS: "EQUALS" >
|   < ERROR: "ERROR" >
|   < ESCAPE: "ESCAPE" >
|   < EVERY: "EVERY" >
|   < EXCEPT: "EXCEPT" >
|   < EXCEPTION: "EXCEPTION" >
|   < EXCLUDE: "EXCLUDE" >
|   < EXCLUDING: "EXCLUDING" >
|   < EXEC: "EXEC" >
|   < EXECUTE: "EXECUTE" >
|   < EXISTS: "EXISTS" >
|   < EXP: "EXP" >
|   < EXPLAIN: "EXPLAIN" >
|   < EXTEND: "EXTEND" >
|   < EXTERNAL: "EXTERNAL" >
|   < EXTRACT: "EXTRACT" >
|   < FALSE: "FALSE" >
|   < FETCH: "FETCH" >
|   < FILTER: "FILTER" >
|   < FINAL: "FINAL" >
|   < FIRST: "FIRST" >
|   < FIRST_VALUE: "FIRST_VALUE">
|   < FLOAT: "FLOAT" >
|   < FLOOR: "FLOOR" >
|   < FOLLOWING: "FOLLOWING" >
|   < FOR: "FOR" >
|   < FORMAT: "FORMAT" >
|   < FOREIGN: "FOREIGN" >
|   < FORTRAN: "FORTRAN" >
|   < FOUND: "FOUND" >
|   < FRAC_SECOND: "FRAC_SECOND" >
|   < FRAME_ROW: "FRAME_ROW" >
|   < FREE: "FREE" >
|   < FREQUENCY: "FREQUENCY" >
|  < FRESHNESS: "FRESHNESS">
|   < FROM: "FROM" >
|   < FULL: "FULL" >
|   < FUNCTION: "FUNCTION" >
|   < FUSION: "FUSION" >
|   < G: "G" >
|   < GENERAL: "GENERAL" >
|   < GENERATED: "GENERATED" >
|   < GEOMETRY: "GEOMETRY" >
|   < GET: "GET" >
|   < GLOBAL: "GLOBAL" >
|   < GO: "GO" >
|   < GOTO: "GOTO" >
|   < GRANT: "GRANT" >
|   < GRANTED: "GRANTED" >
|   < GRAPH: "GRAPH" >
|   < GROUP: "GROUP" >
|   < GROUPING: "GROUPING" >
|   < GROUPS: "GROUPS" >
|   < HAVING: "HAVING" >
|   < HIERARCHY: "HIERARCHY" >
|   < HOLD: "HOLD" >
|   < HOUR: "HOUR" >
|   < IDENTITY: "IDENTITY" >
|   < IMAGE: "IMAGE" >
|   < IMMEDIATE: "IMMEDIATE" >
|   < IMMEDIATELY: "IMMEDIATELY" >
|   < IMPLEMENTATION: "IMPLEMENTATION" >
|   < IMPORT: "IMPORT" >
|   < IN: "IN" >
|   < INCLUDING: "INCLUDING" >
|   < INCREMENT: "INCREMENT" >
|   < INDEX: "INDEX" >
|   < INDICATOR: "INDICATOR" >
|   < INITIAL: "INITIAL" >
|   < INITIALLY: "INITIALLY" >
|   < INNER: "INNER" >
|   < INOUT: "INOUT" >
|   < INPUT: "INPUT" >
|   < INSENSITIVE: "INSENSITIVE" >
|   < INSERT: "INSERT" >
|   < INSTANCE: "INSTANCE" >
|   < INSTANTIABLE: "INSTANTIABLE" >
|   < INT: "INT" >
|   < INTEGER: "INTEGER" >
|   < INTERFACES: "INTERFACES" >
|   < INTERSECT: "INTERSECT" >
|   < INTERSECTION: "INTERSECTION" >
|   < INTERVAL: "INTERVAL" >
|   < INTO: "INTO" >
|   < INVOKER: "INVOKER" >
|   < IS: "IS" >
|   < ISODOW: "ISODOW" >
|   < ISOYEAR: "ISOYEAR" >
|   < ISOLATION: "ISOLATION" >
|   < JAVA: "JAVA" >
|   < JOIN: "JOIN" >
|   < JSON: "JSON" >
|   < JSON_ARRAY: "JSON_ARRAY">
|   < JSON_ARRAYAGG: "JSON_ARRAYAGG">
|   < JSON_EXISTS: "JSON_EXISTS" >
|   < JSON_VALUE: "JSON_VALUE" >
|   < JSON_OBJECT: "JSON_OBJECT">
|   < JSON_OBJECTAGG: "JSON_OBJECTAGG">
|   < JSON_QUERY: "JSON_QUERY" >
|   < K: "K" >
|   < KEY: "KEY" >
|   < KEY_MEMBER: "KEY_MEMBER" >
|   < KEY_TYPE: "KEY_TYPE" >
|   < DISTANCE: "DISTANCE" >
|   < LABEL: "LABEL" >
|   < LAG: "LAG" >
|   < LANGUAGE: "LANGUAGE" >
|   < LARGE: "LARGE" >
|   < LAST: "LAST" >
|   < LAST_VALUE: "LAST_VALUE" >
|   < LATERAL: "LATERAL" >
|   < LEAD: "LEAD" >
|   < LEADING: "LEADING" >
|   < LEFT: "LEFT" >
|   < LENGTH: "LENGTH" >
|   < LEVEL: "LEVEL" >
|   < LIBRARY: "LIBRARY" >
|   < LIKE: "LIKE" >
|   < LIKE_REGEX: "LIKE_REGEX" >
|   < LIMIT: "LIMIT" >
|   < LN: "LN" >
|   < LOCAL: "LOCAL" >
|   < LOCALTIME: "LOCALTIME" >
|   < LOCALTIMESTAMP: "LOCALTIMESTAMP" >
|   < LOCATOR: "LOCATOR" >
|   < LOWER: "LOWER" >
|   < M: "M" >
|   < MANUAL: "MANUAL">
|   < MAP: "MAP" >
|   < MATCH: "MATCH" >
|   < MATCHED: "MATCHED" >
|   < MATCHES: "MATCHES" >
|   < MATCH_NUMBER: "MATCH_NUMBER">
|   < MATCH_RECOGNIZE: "MATCH_RECOGNIZE">
|   < MATERIALIZED: "MATERIALIZED">
|   < MAX: "MAX" >
|   < MAXVALUE: "MAXVALUE" >
|   < MEASURES: "MEASURES" >
|   < MEMBER: "MEMBER" >
|   < MERGE: "MERGE" >
|   < MESSAGE_LENGTH: "MESSAGE_LENGTH" >
|   < MESSAGE_OCTET_LENGTH: "MESSAGE_OCTET_LENGTH" >
|   < MESSAGE_TEXT: "MESSAGE_TEXT" >
|   < META: "META" >
|   < METHOD: "METHOD" >
|   < MICROSECOND: "MICROSECOND" >
|   < MILLISECOND: "MILLISECOND" >
|   < MILLENNIUM: "MILLENNIUM" >
|   < MIN: "MIN" >
|   < MINUTE: "MINUTE" >
|   < MINVALUE: "MINVALUE" >
|   < MOD: "MOD" >
|   < MODIFY: "MODIFY" >
|   < MODIFIES: "MODIFIES" >
|   < MODULE: "MODULE" >
|   < MONTH: "MONTH" >
|   < MORE_: "MORE" >
|   < MULTISET: "MULTISET" >
|   < MUMPS: "MUMPS" >
|   < NAME: "NAME" >
|   < NAMES: "NAMES" >
|   < NAMESPACE: "NAMESPACE" >
|   < NANOSECOND: "NANOSECOND" >
|   < NATIONAL: "NATIONAL" >
|   < NATURAL: "NATURAL" >
|   < NCHAR: "NCHAR" >
|   < NCLOB: "NCLOB" >
|   < NESTING: "NESTING" >
|   < NEW: "NEW" >
|   < NEXT: "NEXT" >
|   < NO: "NO" >
|   < NONE: "NONE" >
|   < NORMALIZE: "NORMALIZE" >
|   < NORMALIZED: "NORMALIZED" >
|   < NOT: "NOT" >
|   < NTH_VALUE: "NTH_VALUE" >
|   < NTILE: "NTILE" >
|   < NULL: "NULL" >
|   < NULLABLE: "NULLABLE" >
|   < NULLIF: "NULLIF" >
|   < NULLS: "NULLS" >
|   < NUMBER: "NUMBER" >
|   < NUMERIC: "NUMERIC" >
|   < OBJECT: "OBJECT" >
|   < OCCURRENCES_REGEX: "OCCURRENCES_REGEX" >
|   < OCTET_LENGTH: "OCTET_LENGTH" >
|   < OCTETS: "OCTETS" >
|   < OF: "OF" >
|   < OFFSET: "OFFSET" >
|   < OLD: "OLD" >
|   < OMIT: "OMIT" >
|   < ON: "ON" >
|   < ONE: "ONE" >
|   < ONLY: "ONLY" >
|   < OPEN: "OPEN" >
|   < OPTION: "OPTION" >
|   < OPTIONS: "OPTIONS" >
|   < OR: "OR" >
|   < ORDER: "ORDER" >
|   < ORDERING: "ORDERING" >
|   < ORDINALITY: "ORDINALITY" >
|   < OTHERS: "OTHERS" >
|   < OUT: "OUT" >
|   < OUTER: "OUTER" >
|   < OUTPUT: "OUTPUT" >
|   < OVER: "OVER" >
|   < OVERLAPS: "OVERLAPS" >
|   < OVERLAY: "OVERLAY" >
|   < OVERRIDING: "OVERRIDING" >
|   < OWNER: "OWNER" >
|   < PAD: "PAD" >
|   < PARAMETER: "PARAMETER" >
|   < PARAMETER_MODE: "PARAMETER_MODE" >
|   < PARAMETER_NAME: "PARAMETER_NAME" >
|   < PARAMETER_ORDINAL_POSITION: "PARAMETER_ORDINAL_POSITION" >
|   < PARAMETER_SPECIFIC_CATALOG: "PARAMETER_SPECIFIC_CATALOG" >
|   < PARAMETER_SPECIFIC_NAME: "PARAMETER_SPECIFIC_NAME" >
|   < PARAMETER_SPECIFIC_SCHEMA: "PARAMETER_SPECIFIC_SCHEMA" >
|   < PARTIAL: "PARTIAL" >
|   < PARTITION: "PARTITION" >
|   < PARTITIONS: "PARTITIONS" >
|   < PASCAL: "PASCAL" >
|   < PASSING: "PASSING" >
|   < PASSTHROUGH: "PASSTHROUGH" >
|   < PAST: "PAST" >
|   < PATH: "PATH" >
|   < PATTERN: "PATTERN" >
|   < PER: "PER" >
|   < PERCENT: "PERCENT" >
|   < PERCENTILE_CONT: "PERCENTILE_CONT" >
|   < PERCENTILE_DISC: "PERCENTILE_DISC" >
|   < PERCENT_RANK: "PERCENT_RANK" >
|   < PERIOD: "PERIOD" >
|   < PERMUTE: "PERMUTE" >
|   < PLACEMENT: "PLACEMENT" >
|   < PLACING: "PLACING" >
|   < PLAN: "PLAN" >
|   < PLI: "PLI" >
|   < PORTION: "PORTION" >
|   < POSITION: "POSITION" >
|   < POSITION_REGEX: "POSITION_REGEX" >
|   < POWER: "POWER" >
|   < PRECEDES: "PRECEDES" >
|   < PRECEDING: "PRECEDING" >
|   < PRECISION: "PRECISION" >
|   < PREPARE: "PREPARE" >
|   < PRESERVE: "PRESERVE" >
|   < PREV: "PREV" >
|   < PRIMARY: "PRIMARY" >
|   < PRIOR: "PRIOR" >
|   < PRIVILEGES: "PRIVILEGES" >
|   < PROCEDURE: "PROCEDURE" >
|   < PUBLIC: "PUBLIC" >
|   < QUARTER: "QUARTER" >
|   < RANGE: "RANGE" >
|   < RANK: "RANK" >
|   < READ: "READ" >
|   < READS: "READS" >
|   < REAL: "REAL" >
|   < RECURSIVE: "RECURSIVE" >
|   < REF: "REF" >
|   < REFERENCES: "REFERENCES" >
|   < REFERENCING: "REFERENCING" >
|   < REGR_AVGX: "REGR_AVGX" >
|   < REGR_AVGY: "REGR_AVGY" >
|   < REGR_COUNT: "REGR_COUNT" >
|   < REGR_INTERCEPT: "REGR_INTERCEPT" >
|   < REGR_R2: "REGR_R2" >
|   < REGR_SLOPE: "REGR_SLOPE" >
|   < REGR_SXX: "REGR_SXX" >
|   < REGR_SXY: "REGR_SXY" >
|   < REGR_SYY: "REGR_SYY" >
|   < RELATIONAL: "RELATIONAL" >
|   < RELATIVE: "RELATIVE" >
|   < RELEASE: "RELEASE" >
|   < RENAME: "RENAME" >
|   < REPEATABLE: "REPEATABLE" >
|   < REPLACE: "REPLACE" >
|   < RESET: "RESET" >
|   < RESTART: "RESTART" >
|   < RESTRICT: "RESTRICT" >
|   < RESULT: "RESULT" >
|   < RETURN: "RETURN" >
|   < RETURNED_CARDINALITY: "RETURNED_CARDINALITY" >
|   < RETURNED_LENGTH: "RETURNED_LENGTH" >
|   < RETURNED_OCTET_LENGTH: "RETURNED_OCTET_LENGTH" >
|   < RETURNED_SQLSTATE: "RETURNED_SQLSTATE" >
|   < RETURNING: "RETURNING" >
|   < RETURNS: "RETURNS" >
|   < REVOKE: "REVOKE" >
|   < RIGHT: "RIGHT" >
|   < ROLE: "ROLE" >
|   < ROLLBACK: "ROLLBACK" >
|   < ROLLUP: "ROLLUP" >
|   < ROUTINE: "ROUTINE" >
|   < ROUTINE_CATALOG: "ROUTINE_CATALOG" >
|   < ROUTINE_NAME: "ROUTINE_NAME" >
|   < ROUTINE_SCHEMA: "ROUTINE_SCHEMA" >
|   < ROW: "ROW" >
|   < ROW_COUNT: "ROW_COUNT" >
|   < ROW_NUMBER: "ROW_NUMBER" >
|   < ROWS: "ROWS" >
|   < RUNNING: "RUNNING" >
|   < SAVEPOINT: "SAVEPOINT" >
|   < SCALAR: "SCALAR" >
|   < SCALE: "SCALE" >
|   < SCHEMA: "SCHEMA" >
|   < SCHEMA_NAME: "SCHEMA_NAME" >
|   < SCOPE: "SCOPE" >
|   < SCOPE_CATALOGS: "SCOPE_CATALOGS" >
|   < SCOPE_NAME: "SCOPE_NAME" >
|   < SCOPE_SCHEMA: "SCOPE_SCHEMA" >
|   < SCROLL: "SCROLL" >
|   < SEARCH: "SEARCH" >
|   < SECOND: "SECOND" >
|   < SECTION: "SECTION" >
|   < SECURITY: "SECURITY" >
|   < SEEK: "SEEK" >
|   < SELECT: "SELECT" >
|   < SELF: "SELF" >
|   < SENSITIVE: "SENSITIVE" >
|   < SEQUENCE: "SEQUENCE" >
|   < SERIALIZABLE: "SERIALIZABLE" >
|   < SERVER: "SERVER" >
|   < SERVER_NAME: "SERVER_NAME" >
|   < SESSION: "SESSION" >
|   < SESSION_USER: "SESSION_USER" >
|   < SET: "SET" >
|   < SETS: "SETS" >
|   < SET_MINUS: "MINUS">
|   < SHOW: "SHOW" >
|   < SIMILAR: "SIMILAR" >
|   < SIMPLE: "SIMPLE" >
|   < SIZE: "SIZE" >
|   < SKIP_: "SKIP" >
|   < SMALLINT: "SMALLINT" >
|   < SOME: "SOME" >
|   < AUDIO: "AUDIO" >
|   < SOURCE: "SOURCE" >
|   < SPACE: "SPACE" >
|   < SPECIFIC: "SPECIFIC" >
|   < SPECIFIC_NAME: "SPECIFIC_NAME" >
|   < SPECIFICTYPE: "SPECIFICTYPE" >
|   < SQL: "SQL" >
|   < SQLEXCEPTION: "SQLEXCEPTION" >
|   < SQLSTATE: "SQLSTATE" >
|   < SQLWARNING: "SQLWARNING" >
|   < SQL_BIGINT: "SQL_BIGINT" >
|   < SQL_BINARY: "SQL_BINARY" >
|   < SQL_BIT: "SQL_BIT" >
|   < SQL_BLOB: "SQL_BLOB" >
|   < SQL_BOOLEAN: "SQL_BOOLEAN" >
|   < SQL_CHAR: "SQL_CHAR" >
|   < SQL_CLOB: "SQL_CLOB" >
|   < SQL_DATE: "SQL_DATE" >
|   < SQL_DECIMAL: "SQL_DECIMAL" >
|   < SQL_DOUBLE: "SQL_DOUBLE" >
|   < SQL_FLOAT: "SQL_FLOAT" >
|   < SQL_JSON: "SQL_JSON" >
|   < SQL_INTEGER: "SQL_INTEGER" >
|   < SQL_INTERVAL_DAY: "SQL_INTERVAL_DAY" >
|   < SQL_INTERVAL_DAY_TO_HOUR: "SQL_INTERVAL_DAY_TO_HOUR" >
|   < SQL_INTERVAL_DAY_TO_MINUTE: "SQL_INTERVAL_DAY_TO_MINUTE" >
|   < SQL_INTERVAL_DAY_TO_SECOND: "SQL_INTERVAL_DAY_TO_SECOND" >
|   < SQL_INTERVAL_HOUR: "SQL_INTERVAL_HOUR" >
|   < SQL_INTERVAL_HOUR_TO_MINUTE: "SQL_INTERVAL_HOUR_TO_MINUTE" >
|   < SQL_INTERVAL_HOUR_TO_SECOND: "SQL_INTERVAL_HOUR_TO_SECOND" >
|   < SQL_INTERVAL_MINUTE: "SQL_INTERVAL_MINUTE" >
|   < SQL_INTERVAL_MINUTE_TO_SECOND: "SQL_INTERVAL_MINUTE_TO_SECOND" >
|   < SQL_INTERVAL_MONTH: "SQL_INTERVAL_MONTH" >
|   < SQL_INTERVAL_SECOND: "SQL_INTERVAL_SECOND" >
|   < SQL_INTERVAL_YEAR: "SQL_INTERVAL_YEAR" >
|   < SQL_INTERVAL_YEAR_TO_MONTH: "SQL_INTERVAL_YEAR_TO_MONTH" >
|   < SQL_LONGVARBINARY: "SQL_LONGVARBINARY" >
|   < SQL_LONGVARCHAR: "SQL_LONGVARCHAR" >
|   < SQL_LONGVARNCHAR: "SQL_LONGVARNCHAR" >
|   < SQL_NCHAR: "SQL_NCHAR" >
|   < SQL_NCLOB: "SQL_NCLOB" >
|   < SQL_NUMERIC: "SQL_NUMERIC" >
|   < SQL_NVARCHAR: "SQL_NVARCHAR" >
|   < SQL_REAL: "SQL_REAL" >
|   < SQL_SMALLINT: "SQL_SMALLINT" >
|   < SQL_TIME: "SQL_TIME" >
|   < SQL_TIMESTAMP: "SQL_TIMESTAMP" >
|   < SQL_TINYINT: "SQL_TINYINT" >
|   < SQL_TSI_DAY: "SQL_TSI_DAY" >
|   < SQL_TSI_FRAC_SECOND: "SQL_TSI_FRAC_SECOND" >
|   < SQL_TSI_HOUR: "SQL_TSI_HOUR" >
|   < SQL_TSI_MICROSECOND: "SQL_TSI_MICROSECOND" >
|   < SQL_TSI_MINUTE: "SQL_TSI_MINUTE" >
|   < SQL_TSI_MONTH: "SQL_TSI_MONTH" >
|   < SQL_TSI_QUARTER: "SQL_TSI_QUARTER" >
|   < SQL_TSI_SECOND: "SQL_TSI_SECOND" >
|   < SQL_TSI_WEEK: "SQL_TSI_WEEK" >
|   < SQL_TSI_YEAR: "SQL_TSI_YEAR" >
|   < SQL_VARBINARY: "SQL_VARBINARY" >
|   < SQL_VARCHAR: "SQL_VARCHAR" >
|   < SQRT: "SQRT" >
|   < START: "START" >
|   < STATE: "STATE" >
|   < STATEMENT: "STATEMENT" >
|   < STATIC: "STATIC" >
|   < STDDEV_POP: "STDDEV_POP" >
|   < STDDEV_SAMP: "STDDEV_SAMP" >
|   < STORE: "STORE" >
|   < STREAM: "STREAM" >
|   < STRUCTURE: "STRUCTURE" >
|   < STYLE: "STYLE" >
|   < SUBCLASS_ORIGIN: "SUBCLASS_ORIGIN" >
|   < SUBMULTISET: "SUBMULTISET" >
|   < SUBSET: "SUBSET" >
|   < SUBSTITUTE: "SUBSTITUTE" >
|   < SUBSTRING: "SUBSTRING" >
|   < SUBSTRING_REGEX: "SUBSTRING_REGEX" >
|   < SUCCEEDS: "SUCCEEDS" >
|   < SUM: "SUM" >
|   < SYMMETRIC: "SYMMETRIC" >
|   < SYSTEM: "SYSTEM" >
|   < SYSTEM_TIME: "SYSTEM_TIME" >
|   < SYSTEM_USER: "SYSTEM_USER" >
|   < TABLE: "TABLE" >
|   < TABLE_NAME: "TABLE_NAME" >
|   < TABLESAMPLE: "TABLESAMPLE" >
|   < TEMPERATURE: "TEMPERATURE" >
|   < TEMPORARY: "TEMPORARY" >
|   < THEN: "THEN" >
|   < TIES: "TIES" >
|   < TIME: "TIME" >
|   < TIMESTAMP: "TIMESTAMP" >
|   < TIMESTAMPADD: "TIMESTAMPADD" >
|   < TIMESTAMPDIFF: "TIMESTAMPDIFF" >
|   < TIMEZONE_HOUR: "TIMEZONE_HOUR" >
|   < TIMEZONE_MINUTE: "TIMEZONE_MINUTE" >
|   < TINYINT: "TINYINT" >
|   < TO: "TO" >
|   < TOP_LEVEL_COUNT: "TOP_LEVEL_COUNT" >
|   < TRAILING: "TRAILING" >
|   < TRANSACTION: "TRANSACTION" >
|   < TRANSACTIONS_ACTIVE: "TRANSACTIONS_ACTIVE" >
|   < TRANSACTIONS_COMMITTED: "TRANSACTIONS_COMMITTED" >
|   < TRANSACTIONS_ROLLED_BACK: "TRANSACTIONS_ROLLED_BACK" >
|   < TRANSFORM: "TRANSFORM" >
|   < TRANSFORMS: "TRANSFORMS" >
|   < TRANSLATE: "TRANSLATE" >
|   < TRANSLATE_REGEX: "TRANSLATE_REGEX" >
|   < TRANSLATION: "TRANSLATION" >
|   < TREAT: "TREAT" >
|   < TRIGGER: "TRIGGER" >
|   < TRIGGER_CATALOG: "TRIGGER_CATALOG" >
|   < TRIGGER_NAME: "TRIGGER_NAME" >
|   < TRIGGER_SCHEMA: "TRIGGER_SCHEMA" >
|   < TRIM: "TRIM" >
|   < TRIM_ARRAY: "TRIM_ARRAY" >
|   < TRUE: "TRUE" >
|   < TRUNCATE: "TRUNCATE" >
|   < TYPE: "TYPE" >
|   < UESCAPE: "UESCAPE" >
|   < UNBOUNDED: "UNBOUNDED" >
|   < UNCOMMITTED: "UNCOMMITTED" >
|   < UNCONDITIONAL: "UNCONDITIONAL" >
|   < UNDER: "UNDER" >
|   < UNION: "UNION" >
|   < UNIQUE: "UNIQUE" >
|   < UNKNOWN: "UNKNOWN" >
|   < UNNAMED: "UNNAMED" >
|   < UNNEST: "UNNEST" >
|   < UPDATE: "UPDATE" >
|   < UPPER: "UPPER" >
|   < UPSERT: "UPSERT" >
|   < USAGE: "USAGE" >
|   < USER: "USER" >
|   < USER_DEFINED_TYPE_CATALOG: "USER_DEFINED_TYPE_CATALOG" >
|   < USER_DEFINED_TYPE_CODE: "USER_DEFINED_TYPE_CODE" >
|   < USER_DEFINED_TYPE_NAME: "USER_DEFINED_TYPE_NAME" >
|   < USER_DEFINED_TYPE_SCHEMA: "USER_DEFINED_TYPE_SCHEMA" >
|   < USING: "USING" >
|   < UTF8: "UTF8" >
|   < UTF16: "UTF16" >
|   < UTF32: "UTF32" >
|   < VALUE: "VALUE" >
|   < VALUES: "VALUES" >
|   < VALUE_OF: "VALUE_OF" >
|   < VAR_POP: "VAR_POP" >
|   < VAR_SAMP: "VAR_SAMP" >
|   < VARBINARY: "VARBINARY" >
|   < VARCHAR: "VARCHAR" >
|   < VARYING: "VARYING" >
|   < VERSION: "VERSION" >
|   < VERSIONING: "VERSIONING" >
|   < VIDEO: "VIDEO" >
|   < VIEW: "VIEW" >
|   < WEEK: "WEEK" >
|   < WHEN: "WHEN" >
|   < WHENEVER: "WHENEVER" >
|   < WHERE: "WHERE" >
|   < WIDTH_BUCKET: "WIDTH_BUCKET" >
|   < WINDOW: "WINDOW" >
|   < WITH: "WITH" >
|   < WITHIN: "WITHIN" >
|   < WITHOUT: "WITHOUT" >
|   < WORK: "WORK" >
|   < WRAPPER: "WRAPPER" >
|   < WRITE: "WRITE" >
|   < XML: "XML" >
|   < YEAR: "YEAR" >
|   < ZONE: "ZONE" >
|   < IF: "IF" >
|   < STORED: "STORED" >
|   < VIRTUAL: "VIRTUAL" >
|   < JAR: "JAR" >
|   < FILE: "FILE" >
|   < ARCHIVE: "ARCHIVE" >
}

/**
 * Parses a non-reserved keyword for use as an identifier.
 *
 * <p>The method is broken up into several sub-methods; without this
 * decomposition, parsers such as Babel with more than ~1,000 non-reserved
 * keywords would generate such deeply nested 'if' statements that javac would
 * fail with a {@link StackOverflowError}.
 *
 * <p>The list is generated from the FMPP config data. To add or remove
 * keywords, modify config.fmpp. For parsers except Babel, make sure that
 * keywords are not reserved by the SQL standard.
 *
 * @see Glossary#SQL2003 SQL:2003 Part 2 Section 5.2
 */
String NonReservedKeyWord() :
{
}
{
    (
        NonReservedKeyWord0of3()
    |   NonReservedKeyWord1of3()
    |   NonReservedKeyWord2of3()
    )
    {
        return unquotedIdentifier();
    }
}

/** @see #NonReservedKeyWord */
void NonReservedKeyWord0of3() :
{
}
{
    (
    <A>
    |    <ABSENT>
    |    <ABSOLUTE>
    |    <ACTION>
    |    <ADA>
    |    <ADAPTERS>
    |    <ADD>
    |    <ADMIN>
    |    <AFTER>
    |    <ALWAYS>
    |    <APPLY>
    |    <ASC>
    |    <ASSERTION>
    |    <ASSIGNMENT>
    |    <ATTRIBUTE>
    |    <ATTRIBUTES>
    |    <BEFORE>
    |    <BERNOULLI>
    |    <BREADTH>
    |    <C>
    |    <CASCADE>
    |    <CATALOG>
    |    <CATALOG_NAME>
    |    <CENTURY>
    |    <CONFIG>
    |    <CHAIN>
    |    <CHARACTER_SET_CATALOG>
    |    <CHARACTER_SET_NAME>
    |    <CHARACTER_SET_SCHEMA>
    |    <CHARACTERISTICS>
    |    <CHARACTERS>
    |    <CLASS_ORIGIN>
    |    <COBOL>
    |    <COLLATION>
    |    <COLLATION_CATALOG>
    |    <COLLATION_NAME>
    |    <COLLATION_SCHEMA>
    |    <COLUMN_NAME>
    |    <COMMAND_FUNCTION>
    |    <COMMAND_FUNCTION_CODE>
    )
}

/** @see #NonReservedKeyWord */
void NonReservedKeyWord1of3() :
{
}
{
    (
    <COMMITTED>
    |    <CONDITION_NUMBER>
    |    <CONDITIONAL>
    |    <CONNECTION>
    |    <CONNECTION_NAME>
    |    <CONSTRAINT_CATALOG>
    |    <CONSTRAINT_NAME>
    |    <CONSTRAINT_SCHEMA>
    |    <CONSTRAINTS>
    |    <CONSTRUCTOR>
    |    <CONTINUE>
    |    <CURSOR_NAME>
    |    <DATA>
    |    <DATABASE>
    |    <DATETIME_INTERVAL_CODE>
    |    <DATETIME_INTERVAL_PRECISION>
    |    <DECADE>
    |    <DEFAULTS>
    |    <DEFERRABLE>
    |    <DEFERRED>
    |    <DEFINED>
    |    <DEFINER>
    |    <DEGREE>
    |    <DEPTH>
    |    <DERIVED>
    |    <DESC>
    |    <DESCRIPTION>
    |    <DESCRIPTOR>
    |    <DIAGNOSTICS>
    |    <DISPATCH>
    |    <DOMAIN>
    |    <DOW>
    |    <DOY>
    |    <DYNAMIC_FUNCTION>
    |    <DYNAMIC_FUNCTION_CODE>
    |    <ENCODING>
    |    <EPOCH>
    |    <ERROR>
    |    <EXCEPTION>
    |    <EXCLUDE>
    |    <EXCLUDING>
    |    <FINAL>
    |    <FIRST>
    |    <FOLLOWING>
    |    <FORMAT>
    |    <FORTRAN>
    |    <FOUND>
    |    <FRAC_SECOND>
    |    <G>
    |    <GENERAL>
    |    <GENERATED>
    |    <GEOMETRY>
    |    <GO>
    |    <GOTO>
    |    <GRANTED>
    |    <HIERARCHY>
    |    <IMMEDIATE>
    |    <IMMEDIATELY>
    |    <IMPLEMENTATION>
    |    <INCLUDING>
    |    <INCREMENT>
    |    <INDEX>
    |    <INITIALLY>
    |    <INPUT>
    |    <INSTANCE>
    |    <INSTANTIABLE>
    |    <INTERFACES>
    |    <INVOKER>
    |    <ISODOW>
    |    <ISOYEAR>
    |    <ISOLATION>
    |    <JAVA>
    |    <JSON>
    |    <K>
    |    <KEY>
    |    <KEY_MEMBER>
    |    <KEY_TYPE>
    |    <LABEL>
    |    <LAST>
    |    <LENGTH>
    |    <LEVEL>
    |    <LIBRARY>
    |    <LOCATOR>
    |    <M>
    |    <MAP>
    |    <MATCHED>
    |    <MATERIALIZED>
    |    <MAXVALUE>
    |    <MICROSECOND>
    |    <MESSAGE_LENGTH>
    |    <MESSAGE_OCTET_LENGTH>
    |    <MESSAGE_TEXT>
    |    <META>
    |    <MILLISECOND>
    |    <MILLENNIUM>
    |    <MINVALUE>
    |    <MODIFY>
    |    <MORE_>
    |    <MUMPS>
    |    <NAME>
    |    <NAMES>
    |    <NANOSECOND>
    |    <NESTING>
    |    <NORMALIZED>
    |    <NULLABLE>
    |    <NULLS>
    |    <NUMBER>
    |    <OBJECT>
    |    <OCTETS>
    |    <OPTION>
    |    <OPTIONS>
    |    <ORDERING>
    |    <ORDINALITY>
    |    <OTHERS>
    )
}

/** @see #NonReservedKeyWord */
void NonReservedKeyWord2of3() :
{
}
{
    (
    <OUTPUT>
    |    <OVERRIDING>
    |    <OWNER>
    |    <PAD>
    |    <PARAMETER_MODE>
    |    <PARAMETER_NAME>
    |    <PARAMETER_ORDINAL_POSITION>
    |    <PARAMETER_SPECIFIC_CATALOG>
    |    <PARAMETER_SPECIFIC_NAME>
    |    <PARAMETER_SPECIFIC_SCHEMA>
    |    <PARTIAL>
    |    <PASCAL>
    |    <PASSING>
    |    <PASSTHROUGH>
    |    <PAST>
    |    <PATH>
    |    <PLACEMENT>
    |    <PLACING>
    |    <PLAN>
    |    <PLI>
    |    <PRECEDING>
    |    <PRESERVE>
    |    <PRIOR>
    |    <PRIVILEGES>
    |    <PUBLIC>
    |    <QUARTER>
    |    <READ>
    |    <RELATIVE>
    |    <RENAME>
    |    <REPEATABLE>
    |    <REPLACE>
    |    <RESTART>
    |    <RESTRICT>
    |    <RETURNED_CARDINALITY>
    |    <RETURNED_LENGTH>
    |    <RETURNED_OCTET_LENGTH>
    |    <RETURNED_SQLSTATE>
    |    <RETURNING>
    |    <ROLE>
    |    <ROUTINE>
    |    <ROUTINE_CATALOG>
    |    <ROUTINE_NAME>
    |    <ROUTINE_SCHEMA>
    |    <ROW_COUNT>
    |    <SCALAR>
    |    <SCALE>
    |    <SCHEMA>
    |    <SCHEMA_NAME>
    |    <SCOPE_CATALOGS>
    |    <SCOPE_NAME>
    |    <SCOPE_SCHEMA>
    |    <SECTION>
    |    <SECURITY>
    |    <SELF>
    |    <SEQUENCE>
    |    <SERIALIZABLE>
    |    <SERVER>
    |    <SERVER_NAME>
    |    <SESSION>
    |    <SETS>
    |    <SIMPLE>
    |    <SIZE>
    |    <SOURCE>
    |    <SPACE>
    |    <SPECIFIC_NAME>
    |    <SQL_BIGINT>
    |    <SQL_BINARY>
    |    <SQL_BIT>
    |    <SQL_BLOB>
    |    <SQL_BOOLEAN>
    |    <SQL_CHAR>
    |    <SQL_CLOB>
    |    <SQL_DATE>
    |    <SQL_DECIMAL>
    |    <SQL_DOUBLE>
    |    <SQL_FLOAT>
    |    <SQL_JSON>
    |    <SQL_INTEGER>
    |    <SQL_INTERVAL_DAY>
    |    <SQL_INTERVAL_DAY_TO_HOUR>
    |    <SQL_INTERVAL_DAY_TO_MINUTE>
    |    <SQL_INTERVAL_DAY_TO_SECOND>
    |    <SQL_INTERVAL_HOUR>
    |    <SQL_INTERVAL_HOUR_TO_MINUTE>
    |    <SQL_INTERVAL_HOUR_TO_SECOND>
    |    <SQL_INTERVAL_MINUTE>
    |    <SQL_INTERVAL_MINUTE_TO_SECOND>
    |    <SQL_INTERVAL_MONTH>
    |    <SQL_INTERVAL_SECOND>
    |    <SQL_INTERVAL_YEAR>
    |    <SQL_INTERVAL_YEAR_TO_MONTH>
    |    <SQL_LONGVARBINARY>
    |    <SQL_LONGVARNCHAR>
    |    <SQL_LONGVARCHAR>
    |    <SQL_NCHAR>
    |    <SQL_NCLOB>
    |    <SQL_NUMERIC>
    |    <SQL_NVARCHAR>
    |    <SQL_REAL>
    |    <SQL_SMALLINT>
    |    <SQL_TIME>
    |    <SQL_TIMESTAMP>
    |    <SQL_TINYINT>
    |    <SQL_TSI_DAY>
    |    <SQL_TSI_FRAC_SECOND>
    |    <SQL_TSI_HOUR>
    |    <SQL_TSI_MICROSECOND>
    |    <SQL_TSI_MINUTE>
    |    <SQL_TSI_MONTH>
    |    <SQL_TSI_QUARTER>
    |    <SQL_TSI_SECOND>
    |    <SQL_TSI_WEEK>
    |    <SQL_TSI_YEAR>
    |    <SQL_VARBINARY>
    |    <SQL_VARCHAR>
    |    <STORE>
    |    <STATE>
    |    <STATEMENT>
    |    <STRUCTURE>
    |    <STYLE>
    |    <SUBCLASS_ORIGIN>
    |    <SUBSTITUTE>
    |    <TABLE_NAME>
    |    <TEMPORARY>
    |    <TIES>
    |    <TIMESTAMPADD>
    |    <TIMESTAMPDIFF>
    |    <TOP_LEVEL_COUNT>
    |    <TRANSACTION>
    |    <TRANSACTIONS_ACTIVE>
    |    <TRANSACTIONS_COMMITTED>
    |    <TRANSACTIONS_ROLLED_BACK>
    |    <TRANSFORM>
    |    <TRANSFORMS>
    |    <TRIGGER_CATALOG>
    |    <TRIGGER_NAME>
    |    <TRIGGER_SCHEMA>
    |    <TYPE>
    |    <UNBOUNDED>
    |    <UNCOMMITTED>
    |    <UNCONDITIONAL>
    |    <UNDER>
    |    <UNNAMED>
    |    <USAGE>
    |    <USER_DEFINED_TYPE_CATALOG>
    |    <USER_DEFINED_TYPE_CODE>
    |    <USER_DEFINED_TYPE_NAME>
    |    <USER_DEFINED_TYPE_SCHEMA>
    |    <UTF8>
    |    <UTF16>
    |    <UTF32>
    |    <VERSION>
    |    <VIEW>
    |    <WEEK>
    |    <WRAPPER>
    |    <WORK>
    |    <WRITE>
    |    <XML>
    |    <ZONE>
    )
}

/* LITERALS */

<DEFAULT, DQID, BTID> TOKEN :
{
    < UNSIGNED_INTEGER_LITERAL: (["0"-"9"])+ >
|
    < APPROX_NUMERIC_LITERAL:
    (<UNSIGNED_INTEGER_LITERAL> | <DECIMAL_NUMERIC_LITERAL>) <EXPONENT> >
|
    < DECIMAL_NUMERIC_LITERAL:
    (["0"-"9"])+(".")?(["0"-"9"])*
    | "."(["0"-"9"])+
    >
|
    < #EXPONENT: ["e","E"] (["+","-"])? (["0"-"9"])+ >
|
    < #HEXDIGIT: ["0"-"9","a"-"f","A"-"F"] >
|
    < #WHITESPACE:
    [ " ","\t","\n","\r","\f" ]
    >
|
    /* To improve error reporting, we allow all kinds of characters,
     * not just hexits, in a binary string literal. */
    < BINARY_STRING_LITERAL: ["x","X"] <QUOTE> ( (~["'"]) | ("''"))* <QUOTE> >
|
    < QUOTED_STRING: <QUOTE> ( (~["'"]) | ("''"))* <QUOTE> >
|
    < PREFIXED_STRING_LITERAL: ("_" <CHARSETNAME> | "N") <QUOTED_STRING> >
|
    < UNICODE_STRING_LITERAL: "U" "&" <QUOTED_STRING> >
|
    < #CHARSETNAME: (["a"-"z","A"-"Z","0"-"9"])
    (["a"-"z","A"-"Z","0"-"9",":",".","-","_"])*
    >
}

<DEFAULT, DQID, BTID> TOKEN :
{
    < UNICODE_QUOTED_ESCAPE_CHAR:
    <QUOTE>
    (~["0"-"9","a"-"f","A"-"F","+","\""," ","\t","\n","\r","\f"])
    <QUOTE>
    >
}

/* SEPARATORS */

<DEFAULT, DQID, BTID> TOKEN :
{
    < LPAREN: "(">
|   < RPAREN: ")">
|   < LBRACE_D: "{" (" ")* ["d","D"] >
|   < LBRACE_T: "{" (" ")* ["t","T"] >
|   < LBRACE_TS: "{" (" ")* ["t","T"] ["s","S"] >
|   < LBRACE_FN: "{" (" ")* ["f","F"] ["n","N"] >
|   < LBRACE: "{" >
|   < RBRACE: "}" >
|   < LBRACKET: "[" >
|   < RBRACKET: "]" >
|   < SEMICOLON: ";" >
|   < DOT: "." >
|   < COMMA: "," >
}

/* OPERATORS */

<DEFAULT, DQID, BTID> TOKEN :
{
    < EQ: "=" >
|   < GT: ">" >
|   < LT: "<" >
|   < HOOK: "?" >
|   < COLON: ":" >
|   < LE: "<=" >
|   < GE: ">=" >
|   < NE: "<>" >
|   < NE2: "!=" >
|   < PLUS: "+" >
|   < MINUS: "-" >
|   < STAR: "*" >
|   < SLASH: "/" >
|   < PERCENT_REMAINDER: "%" >
|   < CONCAT: "||" >
|   < NAMED_ARGUMENT_ASSIGNMENT: "=>" >
|   < DOUBLE_PERIOD: ".." >
|   < QUOTE: "'" >
|   < DOUBLE_QUOTE: "\"" >
|   < VERTICAL_BAR: "|" >
|   < CARET: "^" >
|   < DOLLAR: "$" >
}


/*****************************************
 * Lexical Descriptions                  *
 *****************************************/

TOKEN_MGR_DECLS : {
    List<Integer> lexicalStateStack = new ArrayList<Integer>();

    void pushState() {
      lexicalStateStack.add(curLexState);
    }

    void popState() {
      SwitchTo(lexicalStateStack.remove(lexicalStateStack.size() - 1));
    }
}

/*
Lexical states:

DEFAULT: Identifiers are quoted in brackets, e.g. [My Identifier]
DQID:    Identifiers are double-quoted, e.g. "My Identifier"
BTID:    Identifiers are enclosed in back-ticks, e.g. `My Identifier`
IN_SINGLE_LINE_COMMENT:
IN_FORMAL_COMMENT:
IN_MULTI_LINE_COMMENT:

DEFAULT, DQID, BTID are the 3 'normal states'. Behavior is identical except
for how quoted identifiers are recognized.

After a comment has completed, the lexer returns to the previous state, one
of the 'normal states'.
*/

/* WHITE SPACE */

<DEFAULT, DQID, BTID> SKIP :
{
    " "
|   "\t"
|   "\n"
|   "\r"
|   "\f"
}

/* COMMENTS */

<DEFAULT, DQID, BTID> MORE :
{
    <"/**" ~["/"]> { pushState(); } : IN_FORMAL_COMMENT
}

<DEFAULT, DQID, BTID> MORE :
{
    "/*" { pushState(); } : IN_MULTI_LINE_COMMENT
}

<DEFAULT, DQID, BTID> SKIP :
{
    <SINGLE_LINE_COMMENT: ("//"|"--")(~["\n","\r"])* ("\n"|"\r"|"\r\n")? >
}

<IN_FORMAL_COMMENT>
SPECIAL_TOKEN :
{
    <FORMAL_COMMENT: "*/" > { popState(); }
}

<IN_MULTI_LINE_COMMENT>
SPECIAL_TOKEN :
{
    <MULTI_LINE_COMMENT: "*/" > { popState(); }
}

<IN_FORMAL_COMMENT,IN_MULTI_LINE_COMMENT>
MORE :
{
    < ~[] >
}


/* IDENTIFIERS */

<DEFAULT> TOKEN :
{
    < BRACKET_QUOTED_IDENTIFIER:
    "["
    (
        (~["]","\n","\r"])
    |
        ("]]")
    )+
    "]"
    >
}

<DQID> TOKEN :
{
    < QUOTED_IDENTIFIER:
    "\""
    (
        (~["\"","\n","\r"])
    |
        ("\"\"")
    )+
    "\""
    >
}

<BTID>  TOKEN :
{
    < BACK_QUOTED_IDENTIFIER:
    "`"
    (
        (~["`","\n","\r"])
    |
        ("``")
    )+
    "`"
    >
}

<DEFAULT, DQID, BTID> TOKEN :
{
    < COLLATION_ID:
    (<LETTER>|<DIGIT>)+ (<LETTER>|<DIGIT>|":"|"."|"-"|"_")*
    "$"
    (<LETTER>|"_")+
    ("$" (<LETTER>|<DIGIT>|"_")+)?
    >
|
    < IDENTIFIER: <LETTER> (<LETTER>|<DIGIT>)* >
|
    < UNICODE_QUOTED_IDENTIFIER: "U" "&" <QUOTED_IDENTIFIER> >
|
    < #LETTER:
    [
        "\u0024",
        "\u0041"-"\u005a",
        "\u005f",
        "\u0061"-"\u007a",
        "\u00c0"-"\u00d6",
        "\u00d8"-"\u00f6",
        "\u00f8"-"\u00ff",
        "\u0100"-"\u1fff",
        "\u3040"-"\u318f",
        "\u3300"-"\u337f",
        "\u3400"-"\u3d2d",
        "\u4e00"-"\u9fff",
        "\uf900"-"\ufaff"
    ]
    >
|
    < #DIGIT:
    [
        "\u0030"-"\u0039",
        "\u0660"-"\u0669",
        "\u06f0"-"\u06f9",
        "\u0966"-"\u096f",
        "\u09e6"-"\u09ef",
        "\u0a66"-"\u0a6f",
        "\u0ae6"-"\u0aef",
        "\u0b66"-"\u0b6f",
        "\u0be7"-"\u0bef",
        "\u0c66"-"\u0c6f",
        "\u0ce6"-"\u0cef",
        "\u0d66"-"\u0d6f",
        "\u0e50"-"\u0e59",
        "\u0ed0"-"\u0ed9",
        "\u1040"-"\u1049"
    ]
    >
}

/* Special token to throw a wrench in the works. It is never valid in SQL,
   and so when it occurs, it causes the parser to print which tokens would
   have been valid at that point. Used by SqlAdvisor. */
<DEFAULT, DQID, BTID> TOKEN :
{
    < BEL:
    [
        "\u0007"
    ]
    >
}

/**
 * Defines a production which can never be accepted by the parser.
 * In effect, it tells the parser, "If you got here, you've gone too far."
 * It is used as the default production for parser extension points;
 * derived parsers replace it with a real production when they want to
 * implement a particular extension point.
 */
void UnusedExtension() :
{
}
{
    (
        LOOKAHEAD({false}) <ZONE>
    )
}

// End Parser.jj
