
options {
    STATIC = false;
    IGNORE_CASE = true;
    UNICODE_INPUT = true;
}

PARSER_BEGIN(PolyAlgParserImpl)

package org.polypheny.db.algebra.polyalg.parser;

import java.io.StringReader;
import java.io.Reader;
import org.polypheny.db.languages.ParserFactory;
import org.polypheny.db.languages.ParserPos;
import org.polypheny.db.algebra.polyalg.parser.nodes.PolyAlgLiteral;
import org.polypheny.db.algebra.polyalg.parser.nodes.PolyAlgAliasedArgument;
import org.polypheny.db.algebra.polyalg.parser.nodes.PolyAlgNamedArgument;
import org.polypheny.db.algebra.polyalg.parser.nodes.PolyAlgNode;
import org.polypheny.db.algebra.polyalg.parser.nodes.PolyAlgOperator;
import org.polypheny.db.algebra.polyalg.parser.nodes.PolyAlgNodeList;
import org.polypheny.db.algebra.polyalg.parser.nodes.PolyAlgExpression;
import java.util.Arrays;
import java.util.List;
import java.util.ArrayList;

/**
 * Parses Poly Algebra.
 */
public class PolyAlgParserImpl extends PolyAlgAbstractParserImpl {

    /**
     * ParserFactory implementation for creating parser.
     */
    public static final ParserFactory FACTORY = new ParserFactory() {
        public PolyAlgAbstractParserImpl getParser(Reader reader) {
            final PolyAlgParserImpl parser = new PolyAlgParserImpl(reader);
            /*if (reader instanceof SourceStringReader) {
                final String mql = ((SourceStringReader) reader).getSourceString();
                parser.setOriginalMql(mql);
            }*/
          return parser;
        }
    };

    /** Main entry point. */
    public static void parse(String str) {
        PolyAlgParserImpl parser = new PolyAlgParserImpl(new StringReader(str));


        try {
          parser.Input();
          System.out.println("Successfully parsed input!");
        } catch (Exception e) {
          System.out.println("Could not parse input correctly:");
          System.out.println(e.getMessage());
          e.printStackTrace();
        }
    }

    public PolyAlgParseException normalizeException(Throwable ex) {
        try {
            return convertException(ex);
        } catch (ParseException e) {
            throw new AssertionError(e);
        }
    }

    PolyAlgParseException convertException(Throwable ex) throws ParseException {
        if (ex instanceof PolyAlgParseException) {
            return (PolyAlgParseException) ex;
        }

        ParserPos pos = null;
        int[][] expectedTokenSequences = null;
        String[] tokenImage = null;
        if (ex instanceof ParseException) {
            ParseException pex = (ParseException) ex;
            expectedTokenSequences = pex.expectedTokenSequences;
            tokenImage = pex.tokenImage;
            if (pex.currentToken != null) {
                final Token token = pex.currentToken.next;
                pos = new ParserPos(
                    token.beginLine,
                    token.beginColumn,
                    token.endLine,
                    token.endColumn);
            }
        } else if (ex instanceof TokenMgrError) {
            TokenMgrError tme = (TokenMgrError) ex;
            expectedTokenSequences = null;
            tokenImage = null;
            // Example:
            //    Lexical error at line 3, column 24.  Encountered "#" after "a".
            final java.util.regex.Pattern pattern = java.util.regex.Pattern.compile(
                "(?s)Lexical error at line ([0-9]+), column ([0-9]+).*");
            java.util.regex.Matcher matcher = pattern.matcher(ex.getMessage());
            if (matcher.matches()) {
                int line = Integer.parseInt(matcher.group(1));
                int column = Integer.parseInt(matcher.group(2));
                pos = new ParserPos(line, column, line, column);
            }
        }
        return new PolyAlgParseException(ex.getMessage(), pos, expectedTokenSequences, tokenImage, ex);
    }


    public PolyAlgNode parsePolyAlgEof() throws Exception {
        return Input();
    }

}

PARSER_END(PolyAlgParserImpl)

SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

TOKEN :
{
  <LCURL: "{">
| <RCURL: "}">
| <LPAR: "(">
| <RPAR: ")">
| <LBRACK: "[">
| <RBRACK: "]">
| <SEP: ",">
| <EQUALS: "=">
| <COLON: ":">
| <AS: "AS">
| <IDENTIFIER: (<LETTER> | <IDENTIFIER_SYMBOL>) (<LETTER> | <DIGIT> | <IDENTIFIER_SYMBOL>)+>
| <NUMBER: (<DIGIT>)+ (".")? (<DIGIT>)*>
| <#LETTER: ["_","a"-"z","A"-"Z","ö", "Ö", "ä", "Ä", "ü", "Ü", "à", "À", "ç","Ç", "á", "Á", "è", "È","í","Í", "î", "Î","ó","Ó","ò", "ô", "Ô", "Ò" , "í", "Í", "ë", "Ë", "â", "Â", "ï", "Ï", "é", "É", "ñ", "Ñ", "ß"] >
| <#DIGIT: ["0"-"9"]>
| <#IDENTIFIER_SYMBOL: ["#", "@", "$", "."]>
| <SYMBOL: ~[",","{","}","(",")","[", "]", "\"", "'", "="]>
| <QUOTED:
      "\""
      (
           "\\" ~[]     //any escaped character
      |                 //or
          ~["\"","\\"]  //any character except quote or backslash
      )*
      "\""
      |
      "'"
      (
           "\\" ~[]     //any escaped character
      |                 //or
          ~["'","\\"]  //any character except single-quote or backslash
      )*
      "'">
}

JAVACODE protected ParserPos getPos()
{
    return new ParserPos(
        token.beginLine,
        token.beginColumn,
        token.endLine,
        token.endColumn);
}

/** Root production. */
PolyAlgNode Input() :
{
    PolyAlgNode n;
}
{
    n = Operator() <EOF>
    {return n;}
}


PolyAlgOperator Operator() :
{
    String opName;
    List<PolyAlgNamedArgument> args = null;
    List<PolyAlgOperator> children = null;
}
{
    opName = OpName() <LBRACK> [args = Arguments()] <RBRACK> [<LPAR> [children = ChildOperators()] <RPAR>]
    {return new PolyAlgOperator(opName, args, children, getPos());}
}

List<PolyAlgOperator> ChildOperators() :
{
    PolyAlgOperator o;
    List<PolyAlgOperator> children = new ArrayList<>();
}
{
    o = Operator() {children.add(o);} (<SEP> o = Operator() {children.add(o);})*
    {return children;}
}

List<PolyAlgNamedArgument> Arguments() :
{
    PolyAlgNamedArgument n;
    List<PolyAlgNamedArgument> args = new ArrayList<>();
}
{
    n = NamedArgument() {args.add(n);} (<SEP> n = NamedArgument() {args.add(n);})*
    {return args;}
}

PolyAlgNamedArgument NamedArgument() :
{
    String name = null;
    PolyAlgAliasedArgument arg;
}
{
    [LOOKAHEAD(2) name = ParamName() <EQUALS> ] arg = AliasedArgument()
    {return new PolyAlgNamedArgument(name, arg, getPos());}
}


PolyAlgAliasedArgument AliasedArgument() :
{
    PolyAlgNode arg;
    String alias = null;
}
{
     arg = Argument() [<AS> alias = AliasName() ]
     {return new PolyAlgAliasedArgument(arg, alias, getPos()); }
}

PolyAlgNode Argument() :
{
    PolyAlgNode n;
}
{
     (
         n = Expression()
         |
         n = ListArgument()
     )
     {return n;}
}

PolyAlgNode ListArgument() : // we return a PolyAlgNodeList instead of a List<PolyAlgNode> as an Argument() could also be a PolyAlgExpression
{
    List<PolyAlgNode> args = new ArrayList<>();
    PolyAlgNode n;
}
{
     <LBRACK> n = AliasedArgument() {args.add(n);} (<SEP> n = AliasedArgument() {args.add(n);})* <RBRACK>
     {return new PolyAlgNodeList(args, getPos());}
}

PolyAlgExpression Expression():
{
    List<PolyAlgLiteral> literals = new ArrayList<>();
    List<PolyAlgExpression> childExps = null;
    Token t;
    PolyAlgLiteral l;
    String cast = null;
    PolyAlgExpression exp;
}
{
    (l = Literal() {literals.add(l);})+ [<LPAR> childExps = ChildExpressions() <RPAR>] [<COLON> t = <IDENTIFIER> {cast = t.image;}]  // TODO: handle OVER
    {return new PolyAlgExpression(literals, childExps, cast, getPos());}
    |
    <LPAR> exp = Expression() <RPAR>  // optional outer parentheses
    {return exp;}
}

/*PolyAlgNode OuterExpression() : // outer expressions cannot contain separators, as they could not always be differentiated from a ListArgument
{
    PolyAlgNode n = new PolyAlgLiteral();  // only temporary
}
{
    (
        AnyExpression()
        |
        <LPAR> OuterExpression() <RPAR>  // optional outer parentheses
    )




    {return n;}
}*/

List<PolyAlgExpression> ChildExpressions() : // List of expressions separated by <SEP>
{
    List<PolyAlgExpression> exps = new ArrayList<>();
    PolyAlgExpression e;
}
{
    e = Expression() {exps.add(e);} (<SEP> e = Expression() {exps.add(e);})*
    {return exps;}

    /*((
        <LPAR> InnerExpression() <RPAR>
        |
        <LCURL> InnerExpression() <RCURL>
        |
        Literal()
        |
        <AS>  // inner expressions can contain <AS>, since we know it cannot be an alias for an argument
    ) (<SEP>)* )*  // inner expressions can contain separators!*/
}


PolyAlgLiteral Literal() :
{
    Token t;
    boolean isNumber = false;

}
{
    (
        t = <IDENTIFIER>
        |
        t = <NUMBER> {isNumber = true;}
        |
        t = <SYMBOL>
        |
        t = <QUOTED>
        |
        t = <EQUALS>
    )
    {return new PolyAlgLiteral(t.image, isNumber, getPos());}

}

String OpName() :
{
    Token t;
}
{
    (
        t = <IDENTIFIER>
    )
    {return t.image;}
}

String AliasName() :
{
    Token t;
    String name;
}
{
    (
        name = OpName()
        |
        t = <QUOTED>
        {name = t.image;}
    )
    {return name;}
}

String ParamName() :
{
    String name;
}
{
    name = OpName()
    {return name;}
}